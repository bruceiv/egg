# Egg grammar for Egg grammars.
#
# Author: Aaron Moss

{%
#include <string>

#include "ast.hpp"
#include "utils/strings.hpp"
%}

grammar: ast::grammar_ptr =
		{ psVal = ast::make_ptr<ast::grammar>(); }
			_ (out_action : s { psVal->pre = s; })? 
			(rule : r { *psVal += r; })+ 
			(out_action : s { psVal->post = s; } )? end_of_file

out_action: std::string =
		OUT_BEGIN < ( !OUT_END . )* > OUT_END _ { psVal = psCapture; }

rule: ast::grammar_rule_ptr =
		identifier : s { psVal = ast::make_ptr<ast::grammar_rule>(s); } 
			( BIND type_id : s { psVal->type = s; } )? 
			EQUAL choice : m { psVal->m = m; }

identifier: std::string =
		< [A-Za-z_][A-Za-z_0-9]* > _ { psVal = psCapture; }

type_id: std::string =
		< identifier ( "::" _ type_id )* 
			( '<' _ type_id ( ',' _ type_id )* '>' _ )? > { psVal = psCapture; }

choice: ast::alt_matcher_ptr =
		sequence : m { psVal = ast::make_ptr<ast::alt_matcher>(); *psVal += m; } 
			( PIPE sequence : m { *psVal += m; } )*

sequence: ast::seq_matcher_ptr =
		{ psVal = ast::make_ptr<ast::seq_matcher>(); }
			( expression : e { *psVal += e; } | action : a { *psVal += a; } )+

expression: ast::matcher_ptr =
		AND primary : m { psVal = ast::make_ptr<ast::look_matcher>(m); }
		| NOT primary : m { psVal = ast::make_ptr<ast::not_matcher>(m); }
		| primary : m { psVal = m; } ( 
			OPT { psVal = ast::make_ptr<ast::opt_matcher>(m); }
			| STAR { psVal = ast::make_ptr<ast::many_matcher>(m); }
			| PLUS { psVal = ast::make_ptr<ast::some_matcher>(m); } )?

primary: ast::matcher_ptr =
		identifier : s !( ( BIND type_id )? EQUAL ) 
			{ psVal = ast::make_ptr<ast::rule_matcher>(s); } 
			( BIND identifier : s 
				{ ast::as_ptr<ast::rule_matcher>(psVal)->var = s; } )?
		| OPEN choice : am CLOSE { psVal = am; }
		| char_literal : cm { psVal = cm; }
		| str_literal : sm { psVal = sm; }
		| char_class : rm { psVal = rm; }
		| ANY { psVal = ast::make_ptr<ast::any_matcher>(); }
		| EMPTY { psVal = ast::make_ptr<ast::empty_matcher>(); }
		| BEGIN sequence : bm END { psVal = bm; }

action: ast::action_matcher_ptr =
		'{' < ( action | !'}' . )* > '}' _ 
			{ psVal = ast::make_ptr<ast::action_matcher>(psCapture); }

char_literal: ast::char_matcher_ptr =
		'\'' < character > '\'' _
			{ psVal = ast::make_ptr<ast::char_matcher>(ps[psCatch]); }

str_literal: ast::str_matcher_ptr =
		'\"' < character* > '\"' _
			{ psVal = ast::make_ptr<ast::str_matcher>(psCapture); }

char_class: ast::range_matcher_ptr =
		'[' { psVal = ast::make_ptr<ast::range_matcher>() } 
			( !']' characters : r { *psVal += r; } )* ']' _

characters: ast::char_range =
		character : f '-' character : t { psVal = ast::char_range(f,t); }
		| character : c { psVal = ast::char_range(c); }

character: char =
		'\\' [nrt\'\"\\] { psVal = strings::unescaped_char(ps[psStart+1]); }
		| ![\'\"\\] . { psVal = ps[psStart]; }

OUT_BEGIN =		"{%"
OUT_END =		"%}"
BIND =			':' _
EQUAL =			'=' _
PIPE =			'|' _
AND =			'&' _
NOT =			'!' _
OPT =			'?' _
STAR =			'*' _
PLUS =			'+' _
OPEN =			'(' _
CLOSE =			')' _
ANY =			'.' _
EMPTY =			';' _
BEGIN =			'<' _
END =			'>' _

_ =		 		( space | comment )*
space =			' ' | '\t' | end_of_line
comment =		'#' ( !end_of_line . )* end_of_line
end_of_line = 	"\r\n" | '\n' | '\r'
end_of_file = 	!.

