#pragma once

/* THE FOLLOWING HAS BEEN AUTOMATICALLY GENERATED BY THE EGG PARSER GENERATOR.
 * DO NOT EDIT. */

// {%

/*
 * Copyright (c) 2013 Aaron Moss
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string>

#include "ast.hpp"
#include "utils/strings.hpp"

// %}

#include <string>
#include "parse.hpp"

namespace egg {

	parse::result<ast::grammar_ptr > grammar(parse::state&);
	parse::result<std::string > out_action(parse::state&);
	parse::result<ast::grammar_rule_ptr > rule(parse::state&);
	parse::result<std::string > identifier(parse::state&);
	parse::result<std::string > type_id(parse::state&);
	parse::result<ast::alt_matcher_ptr > choice(parse::state&);
	parse::result<ast::seq_matcher_ptr > sequence(parse::state&);
	parse::result<ast::matcher_ptr > expression(parse::state&);
	parse::result<ast::matcher_ptr > primary(parse::state&);
	parse::result<ast::action_matcher_ptr > action(parse::state&);
	parse::result<ast::char_matcher_ptr > char_literal(parse::state&);
	parse::result<ast::str_matcher_ptr > str_literal(parse::state&);
	parse::result<ast::range_matcher_ptr > char_class(parse::state&);
	parse::result<ast::char_range > characters(parse::state&);
	parse::result<char > character(parse::state&);
	parse::result<> OUT_BEGIN(parse::state&);
	parse::result<> OUT_END(parse::state&);
	parse::result<> BIND(parse::state&);
	parse::result<> EQUAL(parse::state&);
	parse::result<> PIPE(parse::state&);
	parse::result<> AND(parse::state&);
	parse::result<> NOT(parse::state&);
	parse::result<> OPT(parse::state&);
	parse::result<> STAR(parse::state&);
	parse::result<> PLUS(parse::state&);
	parse::result<> OPEN(parse::state&);
	parse::result<> CLOSE(parse::state&);
	parse::result<> ANY(parse::state&);
	parse::result<> EMPTY(parse::state&);
	parse::result<> BEGIN(parse::state&);
	parse::result<> END(parse::state&);
	parse::result<> _(parse::state&);
	parse::result<> space(parse::state&);
	parse::result<> comment(parse::state&);
	parse::result<> end_of_line(parse::state&);
	parse::result<> end_of_file(parse::state&);

	parse::result<ast::grammar_ptr > grammar(parse::state& ps) {
		parse::posn psStart = ps;
		ast::grammar_ptr  psVal;

		ast::grammar_rule_ptr  r;
		std::string  s;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( [&]() { psVal = ast::make_ptr<ast::grammar>();  return true; }()
				&& _(ps)
				&& [&]() { [&]() { 
				parse::posn psStart = ps;
				if ( out_action(ps)(s)
					&& [&]() { psVal->pre = s;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }(); return true; }()
				&& [&]() { if ( [&]() { 
					parse::posn psStart = ps;
					if ( rule(ps)(r)
						&& [&]() { *psVal += r;  return true; }() ) { return true; }
					else { ps = psStart; return false; } }() ) {
				while ( [&]() { 
					parse::posn psStart = ps;
					if ( rule(ps)(r)
						&& [&]() { *psVal += r;  return true; }() ) { return true; }
					else { ps = psStart; return false; } }() )
					;
				return true;
			} else { return false; } }()
				&& [&]() { [&]() { 
				parse::posn psStart = ps;
				if ( out_action(ps)(s)
					&& [&]() { psVal->post = s;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }(); return true; }()
				&& end_of_file(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::grammar_ptr >(); }

	}

	parse::result<std::string > out_action(parse::state& ps) {
		parse::posn psStart = ps;
		std::string  psVal;

		std::string psCapture;
		parse::posn psCatch = ps;
		parse::ind psCatchLen;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( OUT_BEGIN(ps)
				&& [&]() {
				psCatch = ps;
				if ( [&]() { while ( [&]() { 
						parse::posn psStart = ps;
						if ( [&]() {
							parse::posn psStart = ps;
							if ( OUT_END(ps) ) { ps = psStart; return false; }
							else { ps = psStart; return true; } }()
							&& parse::any(ps) ) { return true; }
						else { ps = psStart; return false; } }() )
					;
				return true; }() ) {
					psCatchLen = ps - psCatch;
					psCapture = ps.string(psCatch, psCatchLen);
					return true;
				} else {
					psCatchLen = 0;
					psCapture = std::string("");
					return false;
				} }()
				&& OUT_END(ps)
				&& _(ps)
				&& [&]() { psVal = psCapture;  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<std::string >(); }

	}

	parse::result<ast::grammar_rule_ptr > rule(parse::state& ps) {
		parse::posn psStart = ps;
		ast::grammar_rule_ptr  psVal;

		ast::alt_matcher_ptr  m;
		std::string  s;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( identifier(ps)(s)
				&& [&]() { psVal = ast::make_ptr<ast::grammar_rule>(s);  return true; }()
				&& [&]() { [&]() { 
				parse::posn psStart = ps;
				if ( BIND(ps)
					&& type_id(ps)(s)
					&& [&]() { psVal->type = s;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }(); return true; }()
				&& EQUAL(ps)
				&& choice(ps)(m)
				&& [&]() { psVal->m = m;  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::grammar_rule_ptr >(); }

	}

	parse::result<std::string > identifier(parse::state& ps) {
		parse::posn psStart = ps;
		std::string  psVal;

		std::string psCapture;
		parse::posn psCatch = ps;
		parse::ind psCatchLen;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( [&]() {
				psCatch = ps;
				if ( [&]() { 
					parse::posn psStart = ps;
					if ( ( parse::in_range<'A','Z'>(ps)
						|| parse::in_range<'a','z'>(ps)
						|| parse::matches<'_'>(ps) )
						&& [&]() { while ( ( parse::in_range<'A','Z'>(ps)
							|| parse::in_range<'a','z'>(ps)
							|| parse::matches<'_'>(ps)
							|| parse::in_range<'0','9'>(ps) ) )
						;
					return true; }() ) { return true; }
					else { ps = psStart; return false; } }() ) {
					psCatchLen = ps - psCatch;
					psCapture = ps.string(psCatch, psCatchLen);
					return true;
				} else {
					psCatchLen = 0;
					psCapture = std::string("");
					return false;
				} }()
				&& _(ps)
				&& [&]() { psVal = psCapture;  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<std::string >(); }

	}

	parse::result<std::string > type_id(parse::state& ps) {
		parse::posn psStart = ps;
		std::string  psVal;

		std::string psCapture;
		parse::posn psCatch = ps;
		parse::ind psCatchLen;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( [&]() {
				psCatch = ps;
				if ( [&]() { 
					parse::posn psStart = ps;
					if ( identifier(ps)
						&& [&]() { while ( [&]() { 
							parse::posn psStart = ps;
							if ( parse::matches("::", ps)
								&& _(ps)
								&& type_id(ps) ) { return true; }
							else { ps = psStart; return false; } }() )
						;
					return true; }()
						&& [&]() { [&]() { 
						parse::posn psStart = ps;
						if ( parse::matches<'<'>(ps)
							&& _(ps)
							&& type_id(ps)
							&& [&]() { while ( [&]() { 
								parse::posn psStart = ps;
								if ( parse::matches<','>(ps)
									&& _(ps)
									&& type_id(ps) ) { return true; }
								else { ps = psStart; return false; } }() )
							;
						return true; }()
							&& parse::matches<'>'>(ps)
							&& _(ps) ) { return true; }
						else { ps = psStart; return false; } }(); return true; }() ) { return true; }
					else { ps = psStart; return false; } }() ) {
					psCatchLen = ps - psCatch;
					psCapture = ps.string(psCatch, psCatchLen);
					return true;
				} else {
					psCatchLen = 0;
					psCapture = std::string("");
					return false;
				} }()
				&& [&]() { psVal = psCapture;  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<std::string >(); }

	}

	parse::result<ast::alt_matcher_ptr > choice(parse::state& ps) {
		parse::posn psStart = ps;
		ast::alt_matcher_ptr  psVal;

		ast::seq_matcher_ptr  m;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( sequence(ps)(m)
				&& [&]() { psVal = ast::make_ptr<ast::alt_matcher>(); *psVal += m;  return true; }()
				&& [&]() { while ( [&]() { 
					parse::posn psStart = ps;
					if ( PIPE(ps)
						&& sequence(ps)(m)
						&& [&]() { *psVal += m;  return true; }() ) { return true; }
					else { ps = psStart; return false; } }() )
				;
			return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::alt_matcher_ptr >(); }

	}

	parse::result<ast::seq_matcher_ptr > sequence(parse::state& ps) {
		parse::posn psStart = ps;
		ast::seq_matcher_ptr  psVal;

		ast::action_matcher_ptr  a;
		ast::matcher_ptr  e;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( [&]() { psVal = ast::make_ptr<ast::seq_matcher>();  return true; }()
				&& [&]() { if ( ( [&]() { 
						parse::posn psStart = ps;
						if ( expression(ps)(e)
							&& [&]() { *psVal += e;  return true; }() ) { return true; }
						else { ps = psStart; return false; } }()
					|| [&]() { 
						parse::posn psStart = ps;
						if ( action(ps)(a)
							&& [&]() { *psVal += a;  return true; }() ) { return true; }
						else { ps = psStart; return false; } }() ) ) {
				while ( ( [&]() { 
						parse::posn psStart = ps;
						if ( expression(ps)(e)
							&& [&]() { *psVal += e;  return true; }() ) { return true; }
						else { ps = psStart; return false; } }()
					|| [&]() { 
						parse::posn psStart = ps;
						if ( action(ps)(a)
							&& [&]() { *psVal += a;  return true; }() ) { return true; }
						else { ps = psStart; return false; } }() ) )
					;
				return true;
			} else { return false; } }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::seq_matcher_ptr >(); }

	}

	parse::result<ast::matcher_ptr > expression(parse::state& ps) {
		parse::posn psStart = ps;
		ast::matcher_ptr  psVal;

		ast::matcher_ptr  m;

		if ( ( [&]() { 
				parse::posn psStart = ps;
				if ( AND(ps)
					&& primary(ps)(m)
					&& [&]() { psVal = ast::make_ptr<ast::look_matcher>(m);  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( NOT(ps)
					&& primary(ps)(m)
					&& [&]() { psVal = ast::make_ptr<ast::not_matcher>(m);  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( primary(ps)(m)
					&& [&]() { psVal = m;  return true; }()
					&& [&]() { ( [&]() { 
						parse::posn psStart = ps;
						if ( OPT(ps)
							&& [&]() { psVal = ast::make_ptr<ast::opt_matcher>(m);  return true; }() ) { return true; }
						else { ps = psStart; return false; } }()
					|| [&]() { 
						parse::posn psStart = ps;
						if ( STAR(ps)
							&& [&]() { psVal = ast::make_ptr<ast::many_matcher>(m);  return true; }() ) { return true; }
						else { ps = psStart; return false; } }()
					|| [&]() { 
						parse::posn psStart = ps;
						if ( PLUS(ps)
							&& [&]() { psVal = ast::make_ptr<ast::some_matcher>(m);  return true; }() ) { return true; }
						else { ps = psStart; return false; } }() ); return true; }() ) { return true; }
				else { ps = psStart; return false; } }() ) ) { return parse::match(psVal); }
		else { return parse::fail<ast::matcher_ptr >(); }

	}

	parse::result<ast::matcher_ptr > primary(parse::state& ps) {
		parse::posn psStart = ps;
		ast::matcher_ptr  psVal;

		ast::alt_matcher_ptr  am;
		ast::seq_matcher_ptr  bm;
		ast::char_matcher_ptr  cm;
		ast::range_matcher_ptr  rm;
		std::string  s;
		ast::str_matcher_ptr  sm;

		if ( ( [&]() { 
				parse::posn psStart = ps;
				if ( identifier(ps)(s)
					&& [&]() {
					parse::posn psStart = ps;
					if ( [&]() { 
						parse::posn psStart = ps;
						if ( [&]() { [&]() { 
							parse::posn psStart = ps;
							if ( BIND(ps)
								&& type_id(ps) ) { return true; }
							else { ps = psStart; return false; } }(); return true; }()
							&& EQUAL(ps) ) { return true; }
						else { ps = psStart; return false; } }() ) { ps = psStart; return false; }
					else { ps = psStart; return true; } }()
					&& [&]() { psVal = ast::make_ptr<ast::rule_matcher>(s);  return true; }()
					&& [&]() { [&]() { 
					parse::posn psStart = ps;
					if ( BIND(ps)
						&& identifier(ps)(s)
						&& [&]() { ast::as_ptr<ast::rule_matcher>(psVal)->var = s;  return true; }() ) { return true; }
					else { ps = psStart; return false; } }(); return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( OPEN(ps)
					&& choice(ps)(am)
					&& CLOSE(ps)
					&& [&]() { psVal = am;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( char_literal(ps)(cm)
					&& [&]() { psVal = cm;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( str_literal(ps)(sm)
					&& [&]() { psVal = sm;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( char_class(ps)(rm)
					&& [&]() { psVal = rm;  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( ANY(ps)
					&& [&]() { psVal = ast::make_ptr<ast::any_matcher>();  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( EMPTY(ps)
					&& [&]() { psVal = ast::make_ptr<ast::empty_matcher>();  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( BEGIN(ps)
					&& sequence(ps)(bm)
					&& END(ps)
					&& [&]() { psVal = ast::make_ptr<ast::capt_matcher>(bm);  return true; }() ) { return true; }
				else { ps = psStart; return false; } }() ) ) { return parse::match(psVal); }
		else { return parse::fail<ast::matcher_ptr >(); }

	}

	parse::result<ast::action_matcher_ptr > action(parse::state& ps) {
		parse::posn psStart = ps;
		ast::action_matcher_ptr  psVal;

		std::string psCapture;
		parse::posn psCatch = ps;
		parse::ind psCatchLen;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( [&]() {
				parse::posn psStart = ps;
				if ( OUT_BEGIN(ps) ) { ps = psStart; return false; }
				else { ps = psStart; return true; } }()
				&& parse::matches<'{'>(ps)
				&& [&]() {
				psCatch = ps;
				if ( [&]() { while ( ( action(ps)
						|| [&]() { 
							parse::posn psStart = ps;
							if ( [&]() {
								parse::posn psStart = ps;
								if ( parse::matches<'}'>(ps) ) { ps = psStart; return false; }
								else { ps = psStart; return true; } }()
								&& parse::any(ps) ) { return true; }
							else { ps = psStart; return false; } }() ) )
					;
				return true; }() ) {
					psCatchLen = ps - psCatch;
					psCapture = ps.string(psCatch, psCatchLen);
					return true;
				} else {
					psCatchLen = 0;
					psCapture = std::string("");
					return false;
				} }()
				&& parse::matches<'}'>(ps)
				&& _(ps)
				&& [&]() { psVal = ast::make_ptr<ast::action_matcher>(psCapture);  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::action_matcher_ptr >(); }

	}

	parse::result<ast::char_matcher_ptr > char_literal(parse::state& ps) {
		parse::posn psStart = ps;
		ast::char_matcher_ptr  psVal;

		char  c;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'\''>(ps)
				&& character(ps)(c)
				&& parse::matches<'\''>(ps)
				&& _(ps)
				&& [&]() { psVal = ast::make_ptr<ast::char_matcher>(c);  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::char_matcher_ptr >(); }

	}

	parse::result<ast::str_matcher_ptr > str_literal(parse::state& ps) {
		parse::posn psStart = ps;
		ast::str_matcher_ptr  psVal;

		std::string psCapture;
		parse::posn psCatch = ps;
		parse::ind psCatchLen;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'\"'>(ps)
				&& [&]() {
				psCatch = ps;
				if ( [&]() { while ( character(ps) )
					;
				return true; }() ) {
					psCatchLen = ps - psCatch;
					psCapture = ps.string(psCatch, psCatchLen);
					return true;
				} else {
					psCatchLen = 0;
					psCapture = std::string("");
					return false;
				} }()
				&& parse::matches<'\"'>(ps)
				&& _(ps)
				&& [&]() { psVal = ast::make_ptr<ast::str_matcher>(strings::unescape(psCapture));  return true; }() ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::str_matcher_ptr >(); }

	}

	parse::result<ast::range_matcher_ptr > char_class(parse::state& ps) {
		parse::posn psStart = ps;
		ast::range_matcher_ptr  psVal;

		ast::char_range  r;

		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'['>(ps)
				&& [&]() { psVal = ast::make_ptr<ast::range_matcher>();  return true; }()
				&& [&]() { while ( [&]() { 
					parse::posn psStart = ps;
					if ( [&]() {
						parse::posn psStart = ps;
						if ( parse::matches<']'>(ps) ) { ps = psStart; return false; }
						else { ps = psStart; return true; } }()
						&& characters(ps)(r)
						&& [&]() { *psVal += r;  return true; }() ) { return true; }
					else { ps = psStart; return false; } }() )
				;
			return true; }()
				&& parse::matches<']'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(psVal); }
		else { return parse::fail<ast::range_matcher_ptr >(); }

	}

	parse::result<ast::char_range > characters(parse::state& ps) {
		parse::posn psStart = ps;
		ast::char_range  psVal;

		char  c;
		char  f;
		char  t;

		if ( ( [&]() { 
				parse::posn psStart = ps;
				if ( character(ps)(f)
					&& parse::matches<'-'>(ps)
					&& character(ps)(t)
					&& [&]() { psVal = ast::char_range(f,t);  return true; }() ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( character(ps)(c)
					&& [&]() { psVal = ast::char_range(c);  return true; }() ) { return true; }
				else { ps = psStart; return false; } }() ) ) { return parse::match(psVal); }
		else { return parse::fail<ast::char_range >(); }

	}

	parse::result<char > character(parse::state& ps) {
		parse::posn psStart = ps;
		char  psVal;


		if ( ( [&]() { 
				parse::posn psStart = ps;
				if ( parse::matches<'\\'>(ps)
					&& ( parse::matches<'n'>(ps)(psVal)
					|| parse::matches<'r'>(ps)(psVal)
					|| parse::matches<'t'>(ps)(psVal)
					|| parse::matches<'\''>(ps)(psVal)
					|| parse::matches<'\"'>(ps)(psVal)
					|| parse::matches<'\\'>(ps)(psVal) ) ) { return true; }
				else { ps = psStart; return false; } }()
			|| [&]() { 
				parse::posn psStart = ps;
				if ( [&]() {
					parse::posn psStart = ps;
					if ( ( parse::matches<'\''>(ps)
						|| parse::matches<'\"'>(ps)
						|| parse::matches<'\\'>(ps) ) ) { ps = psStart; return false; }
					else { ps = psStart; return true; } }()
					&& parse::any(ps)(psVal) ) { return true; }
				else { ps = psStart; return false; } }() ) ) { return parse::match(psVal); }
		else { return parse::fail<char >(); }

	}

	parse::result<> OUT_BEGIN(parse::state& ps) {
		parse::posn psStart = ps;

		if ( parse::matches("{%", ps) ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> OUT_END(parse::state& ps) {
		parse::posn psStart = ps;

		if ( parse::matches("%}", ps) ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> BIND(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<':'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> EQUAL(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'='>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> PIPE(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'|'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> AND(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'&'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> NOT(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'!'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> OPT(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'?'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> STAR(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'*'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> PLUS(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'+'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> OPEN(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'('>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> CLOSE(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<')'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> ANY(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'.'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> EMPTY(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<';'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> BEGIN(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'<'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> END(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'>'>(ps)
				&& _(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> _(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { while ( ( space(ps)
				|| comment(ps) ) )
			;
		return true; }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> space(parse::state& ps) {
		parse::posn psStart = ps;


		if ( ( parse::matches<' '>(ps)
			|| parse::matches<'\t'>(ps)
			|| end_of_line(ps) ) ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> comment(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() { 
			parse::posn psStart = ps;
			if ( parse::matches<'#'>(ps)
				&& [&]() { while ( [&]() { 
					parse::posn psStart = ps;
					if ( [&]() {
						parse::posn psStart = ps;
						if ( end_of_line(ps) ) { ps = psStart; return false; }
						else { ps = psStart; return true; } }()
						&& parse::any(ps) ) { return true; }
					else { ps = psStart; return false; } }() )
				;
			return true; }()
				&& end_of_line(ps) ) { return true; }
			else { ps = psStart; return false; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> end_of_line(parse::state& ps) {
		parse::posn psStart = ps;


		if ( ( parse::matches("\r\n", ps)
			|| parse::matches<'\n'>(ps)
			|| parse::matches<'\r'>(ps) ) ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

	parse::result<> end_of_file(parse::state& ps) {
		parse::posn psStart = ps;


		if ( [&]() {
			parse::posn psStart = ps;
			if ( parse::any(ps) ) { ps = psStart; return false; }
			else { ps = psStart; return true; } }() ) { return parse::match(parse::val); }
		else { return parse::fail<parse::value>(); }

	}

} /* namespace egg */

