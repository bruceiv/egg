#-------------------------------------------------------------
#
#  Copyright (C) 2006 by Roman R Redziejowski
#  (http://home.swipnet.se/redz/roman).
#
#  This is free software; you can redistribute and/or modify
#  it under the terms of the GNU Library General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License or (at your option) any later version.
#
#  This file is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#  For more details, see the GNU Library General Public License
#  at http://www.fsf.org/copyleft/gpl.html.
#

#-------------------------------------------------------------
#  Compilation Unit
#-------------------------------------------------------------

CompilationUnit
    = (_ ^| ;) (PackageDeclaration ^| ;) (ImportDeclarationP ^| ;) (DeclarationP ^| ;) $
DeclarationP
    = (SEMI ^| (ModifierP ^| ;) (ClassDeclaration ^| InterfaceDeclaration)) (DeclarationP ^| ;)
    
PackageDeclaration
    = PACKAGE QualifiedIdentifier SEMI

ImportDeclaration
    = IMPORT (STATIC ^| ;) QualifiedIdentifier (DOT STAR ^| ;) SEMI
ImportDeclarationP
    = ImportDeclaration (ImportDeclarationP ^| ;)

#-------------------------------------------------------------
#  Class Declaration
#-------------------------------------------------------------

ClassDeclaration
    = CLASS Identifier 
      (EXTENDS ClassType ^| ;) (IMPLEMENTS ClassTypeList ^| ;)
      ClassBody

ClassBody
    = LWING (ClassBodyDeclarationP ^| ;) RWING

ClassBodyDeclaration
    = SEMI
   ^| (STATIC ^| ;) Block    # Static or Instance Initializer
   ^| (ModifierP ^| ;) MemberDecl   # ClassMemberDeclaration 
ClassBodyDeclarationP = ClassBodyDeclaration (ClassBodyDeclarationP ^| ;)

MemberDecl
    = Type Identifier FormalParameters Dim* 
      (THROWS ClassTypeList ^| ;) (SEMI ^| Block)          # Method
   ^| VOID Identifier FormalParameters
      (THROWS ClassTypeList ^| ;) (SEMI ^| Block)          # Void method
    | Identifier FormalParameters 
      (THROWS ClassTypeList ^| ;) Block                    # Constructor
   ^| InterfaceDeclaration                                 # Interface
   ^| ClassDeclaration                                     # Class
    | Type VariableDeclarator (VariableDeclaratorTR ^| ;)  # Field

#-------------------------------------------------------------
#  Interface Declaration
#-------------------------------------------------------------

InterfaceDeclaration
    = INTERFACE Identifier (EXTENDS ClassTypeList ^| ;) InterfaceBody

InterfaceBody
    = LWING (InterfaceBodyDeclarationP ^| ;) RWING

InterfaceBodyDeclaration
    = (ModifierP ^| ;) InterfaceMemberDecl 
   ^| SEMI
InterfaceBodyDeclarationP = InterfaceBodyDeclaration (InterfaceBodyDeclarationP ^| ;)

InterfaceMemberDecl
    = InterfaceMethodOrFieldDecl
   ^| VOID Identifier VoidInterfaceMethodDeclaratorRest
   ^| InterfaceDeclaration
   ^| ClassDeclaration

InterfaceMethodOrFieldDecl
    = Type Identifier InterfaceMethodOrFieldRest

InterfaceMethodOrFieldRest
    = ConstantDeclaratorsRest SEMI
   ^| InterfaceMethodDeclaratorRest

InterfaceMethodDeclaratorRest
    = FormalParameters (DimP ^| ;) (THROWS ClassTypeList ^| ;) SEMI

VoidInterfaceMethodDeclaratorRest
    = FormalParameters (THROWS ClassTypeList ^| ;) SEMI

ConstantDeclaratorsRest
    = ConstantDeclaratorRest (ConstantDeclaratorTR ^| ;)

ConstantDeclarator
    = Identifier ConstantDeclaratorRest
ConstantDeclaratorTR
    = COMMA ConstantDeclarator (ConstantDeclaratorTR ^| ;)

ConstantDeclaratorRest
    = (DimP ^| ;) EQU VariableInitializer

#-------------------------------------------------------------
#  Variable Declarations
#-------------------------------------------------------------

LocalVariableDeclarationStatement
    = (FINAL ^| ;) Type VariableDeclarator (VariableDeclaratorTR ^| ;) SEMI

VariableDeclarator
    = Identifier (DimP ^| ;) (EQU VariableInitializer ^| ;)
VariableDeclaratorTR
    = COMMA VariableDeclarator (VariableDeclaratorTR ^| ;)

#-------------------------------------------------------------
#  Formal Parameters
#-------------------------------------------------------------

FormalParameters
    = LPAR (FormalParameterDecls ^| ;) RPAR

FormalParameter
    = (FINAL ^| ;) Type VariableDeclaratorId
 
FormalParameterDecls
    = (FINAL ^| ;) Type FormalParameterDeclsRest

FormalParameterDeclsRest
    = VariableDeclaratorId (COMMA FormalParameterDecls ^| ;)

VariableDeclaratorId
    = Identifier (DimP ^| ;)

#-------------------------------------------------------------
#  Statements
#-------------------------------------------------------------

Block
    = LWING (BlockStatementP ^| ;) RWING

BlockStatement 
    = LocalVariableDeclarationStatement
    | (ModifierP ^| ;) ClassDeclaration
    | Statement
BlockStatementP = BlockStatement (BlockStatementP ^| ;)

Statement
    = Block
   ^| ASSERT Expression (COLON Expression ^| ;) SEMI
   ^| IF ParExpression Statement (ELSE Statement)?
   ^| FOR LPAR (ForInit ^| ;) SEMI (Expression ^| ;) SEMI (ForUpdate ^| ;) RPAR Statement
   ^| WHILE ParExpression Statement
   ^| DO Statement WHILE ParExpression SEMI
   ^| TRY Block (CatchP (Finally ^| ;) ^| Finally)
   ^| SWITCH ParExpression LWING (SwitchBlockStatementGroupP ^| ;) RWING
   ^| SYNCHRONIZED ParExpression Block
   ^| RETURN (Expression ^| ;) SEMI
   ^| THROW Expression SEMI
   ^| BREAK (Identifier ^| ;) SEMI
   ^| CONTINUE (Identifier ^| ;) SEMI
   ^| SEMI
   ^| ( StatementExpression SEMI 
      | Identifier COLON Statement )

Catch
    = CATCH LPAR FormalParameter RPAR Block
CatchP = Catch (CatchP ^| ;)
    
Finally
    = FINALLY Block

SwitchBlockStatementGroup
    = SwitchLabel (BlockStatementP ^| ;)
SwitchBlockStatementGroupP = SwitchBlockStatementGroup (SwitchBlockStatementGroupP ^| ;)

SwitchLabel
    = CASE ConstantExpression COLON
   ^| DEFAULT COLON

ForInit
    = (FINAL ^| ;) Type VariableDeclarator (VariableDeclaratorTR ^| ;)
    | StatementExpression (StatementExpressionTR ^| ;)  

ForUpdate 
    = StatementExpression (StatementExpressionTR ^| ;)
    
#-------------------------------------------------------------
#  Expressions
#-------------------------------------------------------------

StatementExpression = Expression
StatementExpressionTR = COMMA StatementExpression (StatementExpressionTR ^| ;)

    # This is more generous than definition in section 14.8, 
    # which allows only specific forms of Expression.
    

ConstantExpression = Expression

Expression = ConditionalExpression (ExpressionR ^| ;)
ExpressionR = AssignmentOperator ConditionalExpression (ExpressionR ^| ;)
ExpressionTR = COMMA Expression (ExpressionTR ^| ;)
    
    # This definition is part of the modification 
    # in JLS Chapter 18
    # to minimize look ahead. In JLS Chapter 15.27, Expression
    # is defined as AssignmentExpression, which is effectively
    # defined as
    # (LeftHandSide AssignmentOperator)* ConditionalExpression.
    # The above is obtained by allowing 
    # ANY ConditionalExpression as LeftHandSide, 
    # which results in accepting statements like 5 = a.
    

AssignmentOperator 
    = EQU
   ^| PLUS_EQU
   ^| MINUS_EQU
   ^| STAR_EQU
   ^| DIV_EQU
   ^| AND_EQU
   ^| OR_EQU
   ^| HAT_EQU
   ^| MOD_EQU
   ^| SL_EQU
   ^| SR_EQU
   ^| BSR_EQU

ConditionalExpression = ConditionalOrExpression (ConditionalExpressionR ^| ;)
ConditionalExpressionR = QUERY Expression COLON ConditionalOrExpression (ConditionalExpressionR ^| ;)

ConditionalOrExpression = ConditionalAndExpression (ConditionalOrExpressionR ^| ;)
ConditionalOrExpressionR = OR_OR ConditionalAndExpression (ConditionalOrExpressionR ^| ;)

ConditionalAndExpression = InclusiveOrExpression (ConditionalAndExpressionR ^| ;)
ConditionalAndExpressionR = AND_AND InclusiveOrExpression (ConditionalAndExpressionR ^| ;)

InclusiveOrExpression = ExclusiveOrExpression (InclusiveOrExpressionR ^| ;)
InclusiveOrExpressionR = OR ExclusiveOrExpression (InclusiveOrExpressionR ^| ;)

ExclusiveOrExpression = AndExpression (ExclusiveOrExpressionR ^| ;)
ExclusiveOrExpressionR = HAT AndExpression (ExclusiveOrExpressionR ^| ;)

AndExpression = EqualityExpression (AndExpressionR ^| ;)
AndExpressionR = AND EqualityExpression (AndExpressionR ^| ;)

EqualityExpression = RelationalExpression (EqualityExpressionR ^| ;)
EqualityExpressionR = (EQUAL ^|  NOT_EQUAL) RelationalExpression (EqualityExpressionR ^| ;)

RelationalExpression = ShiftExpression (RelationalExpressionR ^| ;)
RelationalExpressionR 
    = ((LE ^| GE ^| LT ^| GT) ShiftExpression ^| INSTANCEOF ReferenceType) (RelationalExpressionR ^| ;)

ShiftExpression = AdditiveExpression (ShiftExpressionR ^| ;)
ShiftExpressionR = (SL ^| SR ^| BSR) AdditiveExpression (ShiftExpressionR ^| ;)

AdditiveExpression = MultiplicativeExpression (AdditiveExpressionR ^| ;)
AdditiveExpressionR = (PLUS ^| MINUS) MultiplicativeExpression (AdditiveExpressionR ^| ;)

MultiplicativeExpression = UnaryExpression (MultiplicativeExpressionR ^| ;)
MultiplicativeExpressionR = (STAR ^| DIV ^| MOD) UnaryExpression (MultiplicativeExpressionR ^| ;)

UnaryExpression
    = PrefixOp UnaryExpression
   ^| LPAR Type RPAR UnaryExpression
    | Primary (SelectorP ^| ;) (PostfixOpP ^| ;)

Primary
    = ParExpression
   ^| THIS Arguments?
   ^| SUPER SuperSuffix
   ^| Literal
   ^| NEW Creator
   ^| QualifiedIdentifier IdentifierSuffix?
   ^| BasicType (DimP ^| ;) DOT CLASS
   ^| VOID DOT CLASS

IdentifierSuffix
    = LBRK ( RBRK (DimP ^| ;) DOT CLASS ^| Expression RBRK)
   ^| Arguments
   ^| DOT 
      ( CLASS
     ^| THIS 
     ^| SUPER Arguments 
     ^| NEW InnerCreator 
      )

PrefixOp
    = INC
   ^| DEC
   ^| BANG
   ^| TILDA
   ^| PLUS
   ^| MINUS

PostfixOp
    = INC
   ^| DEC
PostfixOpP = PostfixOp (PostfixOpP ^| ;)

Selector
    = DOT Identifier Arguments?
   ^| DOT THIS
   ^| DOT SUPER SuperSuffix
   ^| DOT NEW InnerCreator
   ^| DimExpr
SelectorP = Selector (SelectorP ^| ;)

SuperSuffix
    = Arguments
   ^| DOT Identifier Arguments?

BasicType
    = ( "byte"
     ^| "short"
     ^| "char"
     ^| "int"
     ^| "long"
     ^| "float"
     ^| "double"
     ^| "boolean"
      ) !LetterOrDigit (_ ^| ;)

Arguments
    = LPAR (Expression (ExpressionTR ^| ;) ^| ;) RPAR

Creator
    = CreatedName ClassCreatorRest
    | (ClassType ^| BasicType) ArrayCreatorRest

CreatedName
    = Identifier IdentifierQR

InnerCreator
    = Identifier ClassCreatorRest

ArrayCreatorRest
    = LBRK ( 
        RBRK (DimP ^| ;) ArrayInitializer 
     ^| Expression RBRK DimExpr* Dim* 
      )
    
    # This is more generous than JLS 15.10. According to that 
    # definition, BasicType must be followed by at least one 
    # DimExpr or by ArrayInitializer.
    
ClassCreatorRest
    =  Arguments ClassBody?

ArrayInitializer
    = LWING 
      (VariableInitializer (VariableInitializerTR ^| ;) (COMMA ^| ;) ^| ;) 
      RWING

VariableInitializer
    = ArrayInitializer
   ^| Expression
VariableInitializerTR = COMMA VariableInitializer (VariableInitializerTR ^| ;)

ParExpression
    = LPAR Expression RPAR

QualifiedIdentifier 
    = Identifier IdentifierQR

Dim = LBRK RBRK
DimP = Dim (DimP ^| ;)

DimExpr
    = LBRK Expression RBRK

#-------------------------------------------------------------
#  Types and Modifiers
#-------------------------------------------------------------

Type
    = (BasicType ^| ClassType) (DimP ^| ;)

ReferenceType
    = BasicType DimP
   ^| ClassType (DimP ^| ;)

ClassType
    = Identifier IdentifierQR
ClassTypeTR = COMMA ClassType (ClassTypeTR ^| ;)

ClassTypeList
    = ClassType (ClassTypeTR ^| ;)

Modifier
    = ( "public"
     ^| "protected"
     ^| "private"
     ^| "static"
     ^| "abstract"
     ^| "final"
     ^| "native"
     ^| "synchronized"
     ^| "transient"
     ^| "volatile"
     ^| "strictfp"
      ) !LetterOrDigit (_ ^| ;)
ModifierP = Modifier (ModifierP ^| ;)
    
    # This common definition of Modifier is part of the 
    # modification in JLS Chapter 18 to minimize look ahead. 
    # The main body of JLS has different lists of modifiers 
    # for different language elements.

#=============================================================
#  Lexical Structure
#=============================================================
#-------------------------------------------------------------
#  JLS 3.6-7  Spacing
#-------------------------------------------------------------

_   = ( [ \t\r\n]  # WhiteSpace
     ^| "/*" _R1   # TraditionalComment
     ^| "//" _R2   # EndOfLineComment
      ) (_ ^| ;)
_R1 = "*/" | . _R1
_R2 = [\r\n] | . _R2

#-------------------------------------------------------------
#  JLS 3.8  Identifiers
#-------------------------------------------------------------

Identifier  = !Keyword Letter (LetterOrDigitP ^| ;) (_ ^| ;)   
IdentifierQR = DOT Identifier IdentifierQR ^| ; 
    
Letter = [a-zA-Z_$]

LetterOrDigit = [a-zA-Z0-9_$]
LetterOrDigitP = LetterOrDigit (LetterOrDigitP ^| ;)

    # These are traditional definitions of letters and digits.
    # JLS defines letters and digits as Unicode characters 
    # recognized as such by special Java procedures, which is 
    # difficult to express in terms of Parsing Expressions.

#-------------------------------------------------------------
#  JLS 3.9  Keywords
#-------------------------------------------------------------

Keyword

    = ( "abstract" 
     ^| "assert"   
     ^| "boolean"  
     ^| "break"    
     ^| "byte"     
     ^| "case"     
     ^| "catch"    
     ^| "char"     
     ^| "class"    
     ^| "continue" 
     ^| "default"  
     ^| "double"   
     ^| "do"       
     ^| "else"     
     ^| "enum"     
     ^| "extends"  
     ^| "false"    
     ^| "finally"  
     ^| "final"    
     ^| "float"    
     ^| "for"      
     ^| "if"       
     ^| "implements"
     ^| "import"   
     ^| "interface"
     ^| "int"      
     ^| "instanceof"
     ^| "long"     
     ^| "native"   
     ^| "new"      
     ^| "null"     
     ^| "package"  
     ^| "private"  
     ^| "protected"
     ^| "public"   
     ^| "return"   
     ^| "short"    
     ^| "static"   
     ^| "strictfp" 
     ^| "super"    
     ^| "switch"   
     ^| "synchronized"
     ^| "this"
     ^| "throws"   
     ^| "throw"    
     ^| "transient"
     ^| "true"     
     ^| "try"      
     ^| "void"     
     ^| "volatile" 
     ^| "while"        
      ) !LetterOrDigit  

ASSERT       = "assert"       !LetterOrDigit (_ ^| ;)
BREAK        = "break"        !LetterOrDigit (_ ^| ;)
CASE         = "case"         !LetterOrDigit (_ ^| ;)
CATCH        = "catch"        !LetterOrDigit (_ ^| ;)
CLASS        = "class"        !LetterOrDigit (_ ^| ;)
CONTINUE     = "continue"     !LetterOrDigit (_ ^| ;)
DEFAULT      = "default"      !LetterOrDigit (_ ^| ;)
DO           = "do"           !LetterOrDigit (_ ^| ;)
ELSE         = "else"         !LetterOrDigit (_ ^| ;)
ENUM         = "enum"         !LetterOrDigit (_ ^| ;)
EXTENDS      = "extends"      !LetterOrDigit (_ ^| ;)
FINALLY      = "finally"      !LetterOrDigit (_ ^| ;)
FINAL        = "final"        !LetterOrDigit (_ ^| ;)
FOR          = "for"          !LetterOrDigit (_ ^| ;)
IF           = "if"           !LetterOrDigit (_ ^| ;)
IMPLEMENTS   = "implements"   !LetterOrDigit (_ ^| ;)
IMPORT       = "import"       !LetterOrDigit (_ ^| ;)
INTERFACE    = "interface"    !LetterOrDigit (_ ^| ;)
INSTANCEOF   = "instanceof"   !LetterOrDigit (_ ^| ;)
NEW          = "new"          !LetterOrDigit (_ ^| ;)
PACKAGE      = "package"      !LetterOrDigit (_ ^| ;)
RETURN       = "return"       !LetterOrDigit (_ ^| ;)
STATIC       = "static"       !LetterOrDigit (_ ^| ;)
SUPER        = "super"        !LetterOrDigit (_ ^| ;)
SWITCH       = "switch"       !LetterOrDigit (_ ^| ;)
SYNCHRONIZED = "synchronized" !LetterOrDigit (_ ^| ;)
THIS         = "this"         !LetterOrDigit (_ ^| ;)
THROWS       = "throws"       !LetterOrDigit (_ ^| ;)
THROW        = "throw"        !LetterOrDigit (_ ^| ;)
TRY          = "try"          !LetterOrDigit (_ ^| ;)
VOID         = "void"         !LetterOrDigit (_ ^| ;)
WHILE        = "while"        !LetterOrDigit (_ ^| ;)

#-------------------------------------------------------------
#  JLS 3.10  Literals
#-------------------------------------------------------------

Literal
    = ( (FloatLiteral | IntegerLiteral) # IntegerLiteral may be a prefix of FloatLiteral
      ^| CharLiteral
      ^| StringLiteral
      ^| "true"  !LetterOrDigit
      ^| "false" !LetterOrDigit
      ^| "null"  !LetterOrDigit
      ) (_ ^| ;)
    
IntegerLiteral
    = ( HexNumeral 
      | OctalNumeral   # May be a prefix of HexNumeral
      | DecimalNumeral # May be a prefix of OctalNumeral
      ) [lL]?
    
DecimalNumeral
    = "0" ^| [1-9] (DigitP ^| ;)       
      
HexNumeral
    = ("0x" ^| "0X") HexDigitP
    
HexDigit
    = [a-fA-F0-9]
HexDigitP = HexDigit (HexDigitP ^| ;)
      
OctalNumeral
    = "0" OctalNumeralP
OctalNumeralP = [0-7] (OctalNumeral ^| ;)
      
FloatLiteral 
    = HexFloat
    | DecimalFloat 

DecimalFloat
    = DigitP "." (DigitP ^| ;)  (Exponent ^| ;) ([fFdD] ^| ;)
    | "." DigitP (Exponent ^| ;) ([fFdD] ^| ;)
    | DigitP Exponent ([fFdD] ^| ;)
    | DigitP (Exponent ^| ;) [fFdD]
    
Exponent 
    = [eE] ('+' ^| '-' ^| ;) DigitP

Digit  = [0-9]
DigitP = Digit (DigitP ^| ;)
    
HexFloat
    = HexSignificand BinaryExponent ([fFdD] ^| ;)

HexSignificand
    = HexNumeral ("." ^| ;)
    | ("0x" ^| "0X") (HexDigitP ^| ;) "." HexDigitP

BinaryExponent
     = [pP] ('+' ^| '-' ^| ;) DigitP

CharLiteral 
    = "\'" (Escape ^| ![\'\\] .) "\'"

StringLiteral 
    = "\"" StringLiteralR
StringLiteralR
    = "\"" | (Escape ^| ![\\] .) StringLiteralR

Escape 
    = "\\" ([btnfr\"\'\\] ^| OctalEscape ^| UnicodeEscape) 

OctalEscape 
    = [0-3][0-7][0-7]
    | [0-7][0-7]
    | [0-7]
    
UnicodeEscape
    = "u" HexDigit HexDigit HexDigit HexDigit
    
    # Unicode escape is not defined in JLS syntax because 
    # unicode characters are processed very early (see 3.10.4).

#-------------------------------------------------------------
#  JLS 3.11-12  Separators, Operators
#-------------------------------------------------------------

AT              =   "@"       (_ ^| ;)
AND             =   "&"![=&]  (_ ^| ;)
AND_AND         =   "&&"      (_ ^| ;)
AND_EQU         =   "&="      (_ ^| ;)
BANG            =   "!" !"="  (_ ^| ;)
BSR             =   ">>>"!"=" (_ ^| ;)
BSR_EQU         =   ">>>="    (_ ^| ;)
COLON           =   ":"       (_ ^| ;)
COMMA           =   ","       (_ ^| ;)
DEC             =   "--"      (_ ^| ;)
DIV             =   "/" !"="  (_ ^| ;)
DIV_EQU         =   "/="      (_ ^| ;)
DOT             =   "."       (_ ^| ;)
EQU             =   "=" !"="  (_ ^| ;)
EQUAL           =   "=="      (_ ^| ;)
GE              =   ">="      (_ ^| ;)
GT              =   ">"![=>]  (_ ^| ;) 
HAT             =   "^"!"="   (_ ^| ;)
HAT_EQU         =   "^="      (_ ^| ;)
INC             =   "++"      (_ ^| ;)
LBRK            =   "["       (_ ^| ;)
LE              =   "<="      (_ ^| ;)
LPAR            =   "("       (_ ^| ;)
LPOINT          =   "<"       (_ ^| ;)
LT              =   "<"![=<]  (_ ^| ;)
LWING           =   "{"       (_ ^| ;)
MINUS           =   "-"!('=' ^| '-')  (_ ^| ;)
MINUS_EQU       =   "-="      (_ ^| ;)
MOD             =   "%"!"="   (_ ^| ;)
MOD_EQU         =   "%="      (_ ^| ;)
NOT_EQUAL       =   "!="      (_ ^| ;)
OR              =   "|"![=|]  (_ ^| ;)
OR_EQU          =   "|="      (_ ^| ;)
OR_OR           =   "||"      (_ ^| ;)
PLUS            =   "+"![=+]  (_ ^| ;)
PLUS_EQU        =   "+="      (_ ^| ;)
QUERY           =   "?"       (_ ^| ;)
RBRK            =   "]"       (_ ^| ;)
RPAR            =   ")"       (_ ^| ;)
RPOINT          =   ">"       (_ ^| ;)
RWING           =   "}"       (_ ^| ;)
SEMI            =   ";"       (_ ^| ;)
SL              =   "<<"!"="  (_ ^| ;)
SL_EQU          =   "<<="     (_ ^| ;)
SR              =   ">>"![=>] (_ ^| ;)
SR_EQU          =   ">>="     (_ ^| ;)
STAR            =   "*"!"="   (_ ^| ;)
STAR_EQU        =   "*="      (_ ^| ;)
TILDA           =   "~"       (_ ^| ;)