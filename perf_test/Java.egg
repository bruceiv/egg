#-------------------------------------------------------------
#
#  Copyright (C) 2006 by Roman R Redziejowski
#  (http://home.swipnet.se/redz/roman).
#
#  This is free software; you can redistribute and/or modify
#  it under the terms of the GNU Library General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License or (at your option) any later version.
#
#  This file is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#  For more details, see the GNU Library General Public License
#  at http://www.fsf.org/copyleft/gpl.html.
#

#-------------------------------------------------------------
#  Compilation Unit
#-------------------------------------------------------------

CompilationUnit
    = _ (PackageDeclaration ^| ;) ImportDeclarationS DeclarationS $
DeclarationS
    = (SEMI ^| ModifierS (ClassDeclaration ^| InterfaceDeclaration)) DeclarationS ^| ;
    
PackageDeclaration
    = PACKAGE QualifiedIdentifier SEMI

ImportDeclaration
    = IMPORT (STATIC ^| ;) QualifiedIdentifier (DOT STAR ^| ;) SEMI
ImportDeclarationS
    = ImportDeclaration ImportDeclarationS ^| ;

#-------------------------------------------------------------
#  Class Declaration
#-------------------------------------------------------------

ClassDeclaration
    = CLASS Identifier 
      (EXTENDS ClassType ^| ;) (IMPLEMENTS ClassTypeList ^| ;)
      ClassBody

ClassBody
    = LWING ClassBodyDeclarationS RWING

ClassBodyDeclaration
    = SEMI
   ^| (STATIC ^| ;) Block    # Static or Instance Initializer
   ^| ModifierS MemberDecl   # ClassMemberDeclaration 
ClassBodyDeclarationS = ClassBodyDeclaration ClassBodyDeclarationS ^| ;   

MemberDecl
    = Type Identifier FormalParameters Dim* 
      (THROWS ClassTypeList ^| ;) (SEMI ^| Block)   # Method
   ^| VOID Identifier FormalParameters
      (THROWS ClassTypeList ^| ;) (SEMI ^| Block)   # Void method
    | Identifier FormalParameters 
      (THROWS ClassTypeList ^| ;) Block             # Constructor
   ^| InterfaceDeclaration                          # Interface
   ^| ClassDeclaration                              # Class
    | Type VariableDeclarator VariableDeclaratorTR  # Field

#-------------------------------------------------------------
#  Interface Declaration
#-------------------------------------------------------------

InterfaceDeclaration
    = INTERFACE Identifier (EXTENDS ClassTypeList ^| ;) InterfaceBody

InterfaceBody
    = LWING InterfaceBodyDeclarationS RWING

InterfaceBodyDeclaration
    = ModifierS InterfaceMemberDecl 
   ^| SEMI
InterfaceBodyDeclarationS = InterfaceBodyDeclaration InterfaceBodyDeclarationS ^| ;

InterfaceMemberDecl
    = InterfaceMethodOrFieldDecl
   ^| VOID Identifier VoidInterfaceMethodDeclaratorRest
   ^| InterfaceDeclaration
   ^| ClassDeclaration

InterfaceMethodOrFieldDecl
    = Type Identifier InterfaceMethodOrFieldRest

InterfaceMethodOrFieldRest
    = ConstantDeclaratorsRest SEMI
   ^| InterfaceMethodDeclaratorRest

InterfaceMethodDeclaratorRest
    = FormalParameters DimS (THROWS ClassTypeList ^| ;) SEMI

VoidInterfaceMethodDeclaratorRest
    = FormalParameters (THROWS ClassTypeList ^| ;) SEMI

ConstantDeclaratorsRest
    = ConstantDeclaratorRest ConstantDeclaratorTR

ConstantDeclarator
    = Identifier ConstantDeclaratorRest
ConstantDeclaratorTR
    = COMMA ConstantDeclarator ConstantDeclaratorTR ^| ;

ConstantDeclaratorRest
    = DimS EQU VariableInitializer

#-------------------------------------------------------------
#  Variable Declarations
#-------------------------------------------------------------

LocalVariableDeclarationStatement
    = (FINAL ^| ;) Type VariableDeclarator VariableDeclaratorTR SEMI

VariableDeclarator
    = Identifier Dim* (EQU VariableInitializer)?
VariableDeclaratorTR
    = COMMA VariableDeclarator VariableDeclaratorTR ^| ;

#-------------------------------------------------------------
#  Formal Parameters
#-------------------------------------------------------------

FormalParameters
    = LPAR (FormalParameterDecls ^| ;) RPAR

FormalParameter
    = (FINAL ^| ;) Type VariableDeclaratorId
 
FormalParameterDecls
    = (FINAL ^| ;) Type FormalParameterDeclsRest

FormalParameterDeclsRest
    = VariableDeclaratorId (COMMA FormalParameterDecls ^| ;)

VariableDeclaratorId
    = Identifier DimS

#-------------------------------------------------------------
#  Statements
#-------------------------------------------------------------

Block
    = LWING BlockStatementS RWING

BlockStatement 
    = LocalVariableDeclarationStatement
    | ModifierS ClassDeclaration
    | Statement
BlockStatementS = BlockStatement BlockStatementS ^| ;

Statement
    = Block
   ^| ASSERT Expression (COLON Expression ^| ;) SEMI
   ^| IF ParExpression Statement (ELSE Statement)?
   ^| FOR LPAR (ForInit ^| ;) SEMI (Expression ^| ;) SEMI (ForUpdate ^| ;) RPAR Statement
   ^| WHILE ParExpression Statement
   ^| DO Statement WHILE ParExpression SEMI
   ^| TRY Block (CatchP (Finally ^| ;) ^| Finally)
   ^| SWITCH ParExpression LWING SwitchBlockStatementGroupS RWING
   ^| SYNCHRONIZED ParExpression Block
   ^| RETURN (Expression ^| ;) SEMI
   ^| THROW Expression SEMI
   ^| BREAK (Identifier ^| ;) SEMI
   ^| CONTINUE (Identifier ^| ;) SEMI
   ^| SEMI
   ^| ( StatementExpression SEMI 
      | Identifier COLON Statement )

Catch
    = CATCH LPAR FormalParameter RPAR Block
CatchP = Catch (CatchP ^| ;)
    
Finally
    = FINALLY Block

SwitchBlockStatementGroup
    = SwitchLabel BlockStatementS
SwitchBlockStatementGroupS = SwitchBlockStatementGroup SwitchBlockStatementGroupS ^| ;

SwitchLabel
    = CASE ConstantExpression COLON
   ^| DEFAULT COLON

ForInit
    = (FINAL ^| ;) Type VariableDeclarator VariableDeclaratorTR
    | StatementExpression StatementExpressionTR  

ForUpdate 
    = StatementExpression StatementExpressionTR
    
#-------------------------------------------------------------
#  Expressions
#-------------------------------------------------------------

StatementExpression
    = Expression
StatementExpressionTR = COMMA StatementExpression StatementExpressionTR ^| ;

    # This is more generous than definition in section 14.8, 
    # which allows only specific forms of Expression.
    

ConstantExpression
    = Expression

Expression
    = ConditionalExpression 
      (AssignmentOperator ConditionalExpression)*
ExpressionTR = COMMA Expression ExpressionTR ^| ;
    
    # This definition is part of the modification 
    # in JLS Chapter 18
    # to minimize look ahead. In JLS Chapter 15.27, Expression
    # is defined as AssignmentExpression, which is effectively
    # defined as
    # (LeftHandSide AssignmentOperator)* ConditionalExpression.
    # The above is obtained by allowing 
    # ANY ConditionalExpression as LeftHandSide, 
    # which results in accepting statements like 5 = a.
    

AssignmentOperator 
    = EQU
   ^| PLUS_EQU
   ^| MINUS_EQU
   ^| STAR_EQU
   ^| DIV_EQU
   ^| AND_EQU
   ^| OR_EQU
   ^| HAT_EQU
   ^| MOD_EQU
   ^| SL_EQU
   ^| SR_EQU
   ^| BSR_EQU

ConditionalExpression
    = ConditionalOrExpression 
      (QUERY Expression COLON ConditionalOrExpression)*

ConditionalOrExpression
    = ConditionalAndExpression (OR_OR ConditionalAndExpression)*

ConditionalAndExpression
    = InclusiveOrExpression (AND_AND InclusiveOrExpression)*

InclusiveOrExpression
    = ExclusiveOrExpression (OR ExclusiveOrExpression)*

ExclusiveOrExpression
    = AndExpression (HAT AndExpression)*

AndExpression
    = EqualityExpression (AND EqualityExpression)*

EqualityExpression
    = RelationalExpression (
        (EQUAL ^|  NOT_EQUAL) RelationalExpression
      )*

RelationalExpression
    = ShiftExpression (
        (LE ^| GE ^| LT ^| GT) ShiftExpression 
        ^| INSTANCEOF ReferenceType
      )*

ShiftExpression
    = AdditiveExpression ((SL ^| SR ^| BSR) AdditiveExpression)*

AdditiveExpression
    = MultiplicativeExpression (
        (PLUS ^| MINUS) MultiplicativeExpression
      )*

MultiplicativeExpression
    = UnaryExpression ((STAR ^| DIV ^| MOD) UnaryExpression)*

UnaryExpression
    = PrefixOp UnaryExpression
   ^| LPAR Type RPAR UnaryExpression
    | Primary (Selector)* (PostfixOp)*

Primary
    = ParExpression
   ^| THIS Arguments?
   ^| SUPER SuperSuffix
   ^| Literal
   ^| NEW Creator
   ^| QualifiedIdentifier IdentifierSuffix?
   ^| BasicType DimS DOT CLASS
   ^| VOID DOT CLASS

IdentifierSuffix
    = LBRK ( RBRK DimS DOT CLASS ^| Expression RBRK)
   ^| Arguments
   ^| DOT 
      ( CLASS
     ^| THIS 
     ^| SUPER Arguments 
     ^| NEW InnerCreator 
      )

PrefixOp
    = INC
   ^| DEC
   ^| BANG
   ^| TILDA
   ^| PLUS
   ^| MINUS

PostfixOp
    = INC
   ^| DEC

Selector
    = DOT Identifier Arguments?
   ^| DOT THIS
   ^| DOT SUPER SuperSuffix
   ^| DOT NEW InnerCreator
   ^| DimExpr

SuperSuffix
    = Arguments
   ^| DOT Identifier Arguments?

BasicType
    = ( "byte"
     ^| "short"
     ^| "char"
     ^| "int"
     ^| "long"
     ^| "float"
     ^| "double"
     ^| "boolean"
      ) !LetterOrDigit _

Arguments
    = LPAR (Expression ExpressionTR ^| ;) RPAR

Creator
    = CreatedName ClassCreatorRest
    | (ClassType ^| BasicType) ArrayCreatorRest

CreatedName
    = Identifier IdentifierQR

InnerCreator
    = Identifier ClassCreatorRest

ArrayCreatorRest
    = LBRK ( 
        RBRK DimS ArrayInitializer 
     ^| Expression RBRK DimExpr* Dim* 
      )
    
    # This is more generous than JLS 15.10. According to that 
    # definition, BasicType must be followed by at least one 
    # DimExpr or by ArrayInitializer.
    
ClassCreatorRest
    =  Arguments ClassBody?

ArrayInitializer
    = LWING 
      (VariableInitializer VariableInitializerTR (COMMA ^| ;) ^| ;) 
      RWING

VariableInitializer
    = ArrayInitializer
   ^| Expression
VariableInitializerTR = COMMA VariableInitializer VariableInitializerTR ^| ;

ParExpression
    = LPAR Expression RPAR

QualifiedIdentifier 
    = Identifier (DOT Identifier)*

Dim = LBRK RBRK
DimS = Dim DimS ^| ;

DimExpr
    = LBRK Expression RBRK

#-------------------------------------------------------------
#  Types and Modifiers
#-------------------------------------------------------------

Type
    = (BasicType ^| ClassType) Dim*

ReferenceType
    = BasicType Dim+
   ^| ClassType Dim*

ClassType
    = Identifier (DOT Identifier)*
ClassTypeTR = COMMA ClassType ClassTypeTR ^| ;

ClassTypeList
    = ClassType ClassTypeTR

Modifier
    = ( "public"
     ^| "protected"
     ^| "private"
     ^| "static"
     ^| "abstract"
     ^| "final"
     ^| "native"
     ^| "synchronized"
     ^| "transient"
     ^| "volatile"
     ^| "strictfp"
      ) !LetterOrDigit _
ModifierS = Modifier ModifierS ^| ;
    
    # This common definition of Modifier is part of the 
    # modification in JLS Chapter 18 to minimize look ahead. 
    # The main body of JLS has different lists of modifiers 
    # for different language elements.

#=============================================================
#  Lexical Structure
#=============================================================
#-------------------------------------------------------------
#  JLS 3.6-7  Spacing
#-------------------------------------------------------------

_   = ( [ \t\r\n]  # WhiteSpace
     ^| "/*" _R1   # TraditionalComment
     ^| "//" _R2   # EndOfLineComment
      )*
_R1 = "*/" | . _R1
_R2 = [\r\n] | . _R2

#-------------------------------------------------------------
#  JLS 3.8  Identifiers
#-------------------------------------------------------------

Identifier  = !Keyword Letter LetterOrDigit* _   
IdentifierQR = DOT Identifier IdentifierQR ^| ; 
    
Letter = [a-zA-Z_$]

LetterOrDigit = [a-zA-Z0-9_$]

    # These are traditional definitions of letters and digits.
    # JLS defines letters and digits as Unicode characters 
    # recognized as such by special Java procedures, which is 
    # difficult to express in terms of Parsing Expressions.

#-------------------------------------------------------------
#  JLS 3.9  Keywords
#-------------------------------------------------------------

Keyword

    = ( "abstract" 
     ^| "assert"   
     ^| "boolean"  
     ^| "break"    
     ^| "byte"     
     ^| "case"     
     ^| "catch"    
     ^| "char"     
     ^| "class"    
     ^| "continue" 
     ^| "default"  
     ^| "double"   
     ^| "do"       
     ^| "else"     
     ^| "enum"     
     ^| "extends"  
     ^| "false"    
     ^| "finally"  
     ^| "final"    
     ^| "float"    
     ^| "for"      
     ^| "if"       
     ^| "implements"
     ^| "import"   
     ^| "interface"
     ^| "int"      
     ^| "instanceof"
     ^| "long"     
     ^| "native"   
     ^| "new"      
     ^| "null"     
     ^| "package"  
     ^| "private"  
     ^| "protected"
     ^| "public"   
     ^| "return"   
     ^| "short"    
     ^| "static"   
     ^| "strictfp" 
     ^| "super"    
     ^| "switch"   
     ^| "synchronized"
     ^| "this"
     ^| "throws"   
     ^| "throw"    
     ^| "transient"
     ^| "true"     
     ^| "try"      
     ^| "void"     
     ^| "volatile" 
     ^| "while"        
      ) !LetterOrDigit  

ASSERT       = "assert"       !LetterOrDigit _
BREAK        = "break"        !LetterOrDigit _
CASE         = "case"         !LetterOrDigit _
CATCH        = "catch"        !LetterOrDigit _
CLASS        = "class"        !LetterOrDigit _
CONTINUE     = "continue"     !LetterOrDigit _
DEFAULT      = "default"      !LetterOrDigit _
DO           = "do"           !LetterOrDigit _
ELSE         = "else"         !LetterOrDigit _
ENUM         = "enum"         !LetterOrDigit _
EXTENDS      = "extends"      !LetterOrDigit _
FINALLY      = "finally"      !LetterOrDigit _
FINAL        = "final"        !LetterOrDigit _
FOR          = "for"          !LetterOrDigit _
IF           = "if"           !LetterOrDigit _
IMPLEMENTS   = "implements"   !LetterOrDigit _
IMPORT       = "import"       !LetterOrDigit _
INTERFACE    = "interface"    !LetterOrDigit _
INSTANCEOF   = "instanceof"   !LetterOrDigit _
NEW          = "new"          !LetterOrDigit _
PACKAGE      = "package"      !LetterOrDigit _
RETURN       = "return"       !LetterOrDigit _
STATIC       = "static"       !LetterOrDigit _
SUPER        = "super"        !LetterOrDigit _
SWITCH       = "switch"       !LetterOrDigit _
SYNCHRONIZED = "synchronized" !LetterOrDigit _
THIS         = "this"         !LetterOrDigit _
THROWS       = "throws"       !LetterOrDigit _
THROW        = "throw"        !LetterOrDigit _
TRY          = "try"          !LetterOrDigit _
VOID         = "void"         !LetterOrDigit _
WHILE        = "while"        !LetterOrDigit _

#-------------------------------------------------------------
#  JLS 3.10  Literals
#-------------------------------------------------------------

Literal
    = ( (FloatLiteral | IntegerLiteral) # IntegerLiteral may be a prefix of FloatLiteral
      ^| CharLiteral
      ^| StringLiteral
      ^| "true"  !LetterOrDigit
      ^| "false" !LetterOrDigit
      ^| "null"  !LetterOrDigit
      ) _
    
IntegerLiteral
    = ( HexNumeral 
      | OctalNumeral   # May be a prefix of HexNumeral
      | DecimalNumeral # May be a prefix of OctalNumeral
      ) [lL]?
    
DecimalNumeral
    = "0" ^| [1-9]Digit*         
      
HexNumeral
    = ("0x" ^| "0X") HexDigit+ 
    
HexDigit
    = [a-fA-F0-9]
HexDigitS = HexDigit HexDigitS ^| ;
      
OctalNumeral
    = "0" [0-7]+ 
      
FloatLiteral 
    = HexFloat
    | DecimalFloat 

DecimalFloat
    = DigitP "." Digit*  Exponent? [fFdD]?
    | "." Digit+ Exponent? [fFdD]?
    | DigitP Exponent [fFdD]?
    | Digit+ Exponent? [fFdD]
    
Exponent 
    = [eE] ('+' ^| '-' ^| ;) Digit+ 

Digit  = [0-9]
DigitP = Digit (DigitP ^| ;)
    
HexFloat
    = HexSignificand BinaryExponent [fFdD]?

HexSignificand
    = HexNumeral "."?
    | ("0x" ^| "0X") HexDigitS "." HexDigit+

BinaryExponent
     = [pP] ('+' ^| '-')? Digit+

CharLiteral 
    = "\'" (Escape ^| ![\'\\] .) "\'"

StringLiteral 
    = "\"" StringLiteralR
StringLiteralR
    = "\"" | (Escape ^| ![\\] .) StringLiteralR

Escape 
    = "\\" ([btnfr\"\'\\] ^| OctalEscape ^| UnicodeEscape) 

OctalEscape 
    = [0-3][0-7][0-7]
    | [0-7][0-7]
    | [0-7]
    
UnicodeEscape
    = "u" HexDigit HexDigit HexDigit HexDigit
    
    # Unicode escape is not defined in JLS syntax because 
    # unicode characters are processed very early (see 3.10.4).

#-------------------------------------------------------------
#  JLS 3.11-12  Separators, Operators
#-------------------------------------------------------------

AT              =   "@"       _
AND             =   "&"![=&]  _
AND_AND         =   "&&"      _
AND_EQU         =   "&="      _
BANG            =   "!" !"="  _
BSR             =   ">>>"!"=" _
BSR_EQU         =   ">>>="    _
COLON           =   ":"       _
COMMA           =   ","       _
DEC             =   "--"      _
DIV             =   "/" !"="  _
DIV_EQU         =   "/="      _
DOT             =   "."       _
EQU             =   "=" !"="  _
EQUAL           =   "=="      _
GE              =   ">="      _
GT              =   ">"![=>]  _ 
HAT             =   "^"!"="   _
HAT_EQU         =   "^="      _
INC             =   "++"      _
LBRK            =   "["       _
LE              =   "<="      _
LPAR            =   "("       _
LPOINT          =   "<"       _
LT              =   "<"![=<]  _
LWING           =   "{"       _
MINUS           =   "-"!('=' ^| '-')  _
MINUS_EQU       =   "-="      _
MOD             =   "%"!"="   _
MOD_EQU         =   "%="      _
NOT_EQUAL       =   "!="      _
OR              =   "|"![=|]  _
OR_EQU          =   "|="      _
OR_OR           =   "||"      _
PLUS            =   "+"![=+]  _
PLUS_EQU        =   "+="      _
QUERY           =   "?"       _
RBRK            =   "]"       _
RPAR            =   ")"       _
RPOINT          =   ">"       _
RWING           =   "}"       _
SEMI            =   ";"       _
SL              =   "<<"!"="  _
SL_EQU          =   "<<="     _
SR              =   ">>"![=>] _
SR_EQU          =   ">>="     _
STAR            =   "*"!"="   _
STAR_EQU        =   "*="      _
TILDA           =   "~"       _
