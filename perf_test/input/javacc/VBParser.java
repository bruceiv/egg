/* Generated By:JJTree&JavaCC: Do not edit this line. VBParser.java */
package cager.parser;

import java.io.*;

public class VBParser/*@bgen(jjtree)*/implements VBParserTreeConstants, VBParserConstants {/*@bgen(jjtree)*/
  protected JJTVBParserState jjtree = new JJTVBParserState();
  final public ASTCompilationUnit CompilationUnit() throws ParseException
  {
      return CompilationUnit(false);
  }

  private void jjtreeOpenNodeScope(Node n)
  {
      ((SimpleNode)n).setFirstToken(getToken(1));
  }


  private void jjtreeCloseNodeScope(Node n)
  {
      // Check that we have consumed at least one token.
      SimpleNode sn = (SimpleNode)n;
      if (sn.getFirstToken() == getToken(1))
      {
          // Not consumed any tokens. Set the first token to null
          // to indicate that the list is empty. Set the last
          // token to the "next" token, so that if we create children
          // within this node, we know where to link in the corresponding
          // tokens.
          sn.setFirstToken(null);
          sn.setLastToken(getToken(1));
      }
      else
      {
          sn.setLastToken(getToken(0));
      }
  }


    /**
    **  do the next tokens indicate the end of a block of
    **  statements (see the "Statements" production for an explanation
    ** of what is going on).
    */

    private boolean isEndBlock()
    {
        switch (getToken(1).kind)
        {
            case ELSEIF:
            case ELSE:
            case LOOP:
            case WEND:
            case NEXT:
            case CASE:
            case EOF:
                return true;
            case END:
                switch (getToken(2).kind)
                {
                    case IF:
                    case WITH:
                    case SELECT:
                    case SUB:
                    case FUNCTION:
                    case PROPERTY:
                        return true;
                }
        }

        return false;
    }

  /**
  **    Used to distinguish "a.b" (object a's method called b) and "a .b" (".b" is a parameter to method a).
  **    See
  */
  private boolean isBinarySuffix()
  {
      Token t = getToken(1);
      int kind = t.kind;

      //System.out.println("isBinarySuffix: " + (t.specialToken == null && (kind == DOT || kind == LPAREN || kind == BANG)));
      //(new Exception()).printStackTrace();

      // It is a binary suffix if it is not preceded by a space, and it is a ".", "(", or "!".

      return t.specialToken == null && (kind == DOT || kind == LPAREN || kind == BANG);
  }


  /**
  **    Some VB contructs have such preculiar syntax that I have decided not to attempt to parse
  **    them. For example the built-in line "method" has the syntax:
  **        Line [Step] (x1, y1) - [Step] (x2, y2), [color], [B][F]
  **    so a call could look like:
  **        Line (X1, Y1)-Step(X2, Y2), Color, BF
  **    See also: SpecialStatement
  */

  static
  private boolean isSpecialMethod(String name)
  {
      name = name.toLowerCase();

      //System.out.println("IsSpecialMethod " + name);

      return name.equals("print") ||
             name.equals("line") ||     // NB: Covers "Line" and "Line Input"
             name.equals("circle") ||
             name.equals("pset") ||
             name.equals("point") ||
             //name.equals("write") ||
             //name.equals("read") ||
             name.equals("scale") ||
             //name.equals("input") ||
             name.equals("seek");
  }

  private boolean isIdentifier(String identifier)
  {
      return isIdentifier(identifier, 1);
  }

  private boolean isIdentifier(String identifier, int token)
  {
      Token t = getToken(token);
      return t.kind == IDENTIFIER && t.image.equalsIgnoreCase(identifier);
  }

  /**
  **    VB provides a Name statement of the form:
  **        Name <File> As <NewName>
  **    This requires special processing, but I have not used the "isSpecialMethod"
  **    trick above, as "Name" is too frequently used as a method / property name.
  **    This method attempts to distinguish the two cases.
  */

  private boolean isNameStatement()
  {
      // Look for <Name> Expr1 <As> Expr2

      if (!isIdentifier("Name"))
        return false;

      // Next token must be preceded by a space, .i.e do not allow
      //    Name.Method As:=12
      if (getToken(2).specialToken == null)
        return false;


      // Look forwards for an "As" token (until end of line).
      for (int i = 2; ; i++)
      {
          Token t = getToken(i);
          if (t.kind == EOF || t.kind == EOL)
            return false;
          if (t.kind == AS)
          {
            // Must be preceded and followed by white space.
            if (t.specialToken != null && getToken(i + 1).specialToken != null)
                return true;
          }
      }
  }


  private void getAnyToken() throws ParseException
  {
      getNextToken();
  }

    private void skipToEndSection()
    {
        while (true)
        {
            Token tok = getToken(1);

            if (tok.kind == EOF)
                break;

            if (tok.kind == END && tok.specialToken == null)
            {
                // Found a line starting with word END. Skip
                // this line as well, and we should be in business.

                  while (getToken(1).kind != EOL)
                  {
                      getNextToken();
                  }

                break;
            }

            getNextToken();
        }
    }

    private void skipToBegin()
    {
        while (true)
        {
            Token tok = getToken(1);

            if (tok.kind == EOF)
                break;

            if (tok.kind == IDENTIFIER && tok.specialToken == null && tok.image.equalsIgnoreCase("BEGIN"))
            {
                // Found a line starting with word BEGIN.

                return;
            }

            getNextToken();
        }
    }


    private boolean attemptErrorRecovery = false;
    public boolean getAttemptErrorRecovery()
    {
        return attemptErrorRecovery;
    }
    public void setAttemptErrorRecovery(boolean val)
    {
        attemptErrorRecovery = val;
    }

    private void handleParseError(ParseException e) throws ParseException
    {
       System.out.println("========================================================================================");
       System.out.println("Error at line " + getToken(1).beginLine + ": " + getToken(1).image );
       System.out.println("Statement not recognised");
       e.printStackTrace();
       error_skiptobefore(EOL);
    }

  public static void main(String args[]) throws Exception {
    VBParser parser;
    SimpleNode node;

    if (args.length == 1) {
      System.out.println("VB Parser:  Reading from file " + args[0] + " . . .");
      try {
        parser = new VBParser(new FileInputStream(args[0]));
      } catch (FileNotFoundException e) {
        System.out.println("VB Parser:  File " + args[0] + " not found.");
        return;
      }
    }
    else
    {
      throw new ParseException("VB Parser:  Usage is \"java VBParser inputfile outputfile\"");
    }

    try {
      parser.setAttemptErrorRecovery(true);
      node = parser.CompilationUnit(false);
      //node = (SimpleNode)(parser.ExprTest());
//      PrintWriter ostr = new PrintWriter(new FileWriter(args[1]));

//    node.jjtAccept(new VBErrHandlerVisitor(), null);

      node.dump(">");

      System.out.println(node.allText(true));
      System.out.println("VBParser:  Parsing completed successfully.");
    } catch (ParseException e) {
      System.out.println("VBParser:  Encountered errors during parse.");
      System.out.println(e);
      e.printStackTrace();
    }
  }

/*****************************************
 * THE VB LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

/*
**  NB: There is also a no-argument version of CompilationUnit defined above.
*/
  final public ASTCompilationUnit CompilationUnit(boolean includeProlog) throws ParseException {
 /*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (isIdentifier("VERSION")) {
        jj_consume_token(IDENTIFIER);
        Prolog(includeProlog);
      } else {
        ;
      }
      label_1:
      while (true) {
        if (jj_2_1(4)) {
          ;
        } else {
          break label_1;
        }
        ModuleLevelStatements();
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIM:
        case FRIEND:
        case FUNCTION:
        case GLOBAL:
        case PRIVATE:
        case PROPERTY:
        case PUBLIC:
        case STATIC:
        case SUB:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_2;
        }
        ProcDeclaration();
        label_3:
        while (true) {
          jj_consume_token(EOL);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EOL:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_3;
          }
        }
      }
      jj_consume_token(0);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
    throw new Error("Missing return statement in function");
  }

/**
**  VB files start with a prolog (invisible to a user in the IDE). If includeProlog is set to
**  true we will parse it, generating ASTFormItems.
*/
  final public void Prolog(boolean includeProlog) throws ParseException {
    if (includeProlog) {
          skipToBegin();
      FormItem();
    } else {
          skipToEndSection();
    }
  }

/*
**  Recursively read the Form items.
*/
  final public void FormItem() throws ParseException {
 /*@bgen(jjtree) FormItem */
  ASTFormItem jjtn000 = new ASTFormItem(JJTFORMITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_4(2147483647) && (getToken(1).image.equalsIgnoreCase("BEGIN"))) {
        jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          TypeName();
          Name();
          break;
        default:
          jj_la1[2] = jj_gen;
          ;
        }
        Eol();
        label_4:
        while (true) {
          if (jj_2_2(1)) {
            ;
          } else {
            break label_4;
          }
          FormItem();
        }
        jj_consume_token(END);
        Eol();
      } else if (jj_2_5(2147483647) && (getToken(1).image.equalsIgnoreCase("BEGINPROPERTY"))) {
        jj_consume_token(IDENTIFIER);
        PrimaryExpression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          Guid();
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        Eol();
        label_5:
        while (true) {
          if (jj_2_3(1)) {
            ;
          } else {
            break label_5;
          }
          FormItem();
        }
        jj_consume_token(ENDPROPERTY);
        Eol();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
        case STEP:
        case TYPE:
        case IDENTIFIER:
        case DOT:
        case BANG:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PROPERTY:
          case STEP:
          case IDENTIFIER:
          case DOT:
          case BANG:
            PrimaryExpression();
            break;
          case TYPE:
            jj_consume_token(TYPE);
            break;
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(ASSIGN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DOLLAR:
          case MINUS:
          case EXPO:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MINUS:
              jj_consume_token(MINUS);
              break;
            case DOLLAR:
              jj_consume_token(DOLLAR);
              break;
            case EXPO:
              jj_consume_token(EXPO);
              break;
            default:
              jj_la1[5] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[6] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STRING_LITERAL:
          case FALSE:
          case TRUE:
          case INTEGER_LITERAL:
          case LONG_LITERAL:
          case FLOATING_POINT_LITERAL:
          case DATE_LITERAL:
          case IDENTIFIER:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case STRING_LITERAL:
            case FALSE:
            case TRUE:
            case INTEGER_LITERAL:
            case LONG_LITERAL:
            case FLOATING_POINT_LITERAL:
            case DATE_LITERAL:
              Literal();
              break;
            case IDENTIFIER:
              jj_consume_token(IDENTIFIER);
              break;
            default:
              jj_la1[7] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[8] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case HEX_DISPLACEMENT:
            jj_consume_token(HEX_DISPLACEMENT);
            break;
          default:
            jj_la1[9] = jj_gen;
            ;
          }
          Eol();
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void Guid() throws ParseException {
    jj_consume_token(LBRACE);
    GuidValue();
    jj_consume_token(RBRACE);
  }

  void GuidValue() throws ParseException {
    while (!getToken(1).image.equals("}"))
        getNextToken();
  }

// ==============================================================================================================================
/**
**  The following are all statements that can appear at the module level,
**  i.e outside of subs etc.
**  YOU MAY WANT TO SKIP OVER THESE.
*/
  final public void ModuleLevelStatements() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPTION:
      OptionStatement();
      Eos();
      break;
    case IMPLEMENTS:
      ImplementsDecl();
      Eos();
      break;
    case DEFMODE:
      DefModeStatement();
      break;
    default:
      jj_la1[12] = jj_gen;
      if (jj_2_6(2)) {
        TypeDeclaration();
        Eos();
      } else if (jj_2_7(2)) {
        EventDeclaration();
        Eos();
      } else if (jj_2_8(2)) {
        ConstDeclaration();
        Eos();
      } else if (jj_2_9(2)) {
        EnumDeclaration();
        Eos();
      } else if (jj_2_10(2)) {
        DeclareStatement();
        Eos();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIM:
        case FRIEND:
        case GLOBAL:
        case PRIVATE:
        case PUBLIC:
        case STATIC:
          ModLevelDeclaration();
          Eos();
          break;
        default:
          jj_la1[13] = jj_gen;
          if (isIdentifier("Attribute")) {
            jj_consume_token(IDENTIFIER);
            PrimaryExpression();
            jj_consume_token(ASSIGN);
            Expression();
            label_6:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[11] = jj_gen;
                break label_6;
              }
              jj_consume_token(COMMA);
              Expression();
            }
            Eos();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case EOL:
              Eol();
              break;
            default:
              jj_la1[14] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
  }

  final public void OptionStatement() throws ParseException {
 /*@bgen(jjtree) Option */
  ASTOption jjtn000 = new ASTOption(JJTOPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(OPTION);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          AnyName();
          break;
        case STRING_LITERAL:
        case FALSE:
        case TRUE:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
          Literal();
          break;
        case PRIVATE:
          jj_consume_token(PRIVATE);
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case FALSE:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PRIVATE:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TRUE:
        case TYPE:
        case TYPEOF:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_7;
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ModLevelDeclaration() throws ParseException {
 /*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ModScopeDecl();
      VariableDeclaration();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_8;
        }
        jj_consume_token(COMMA);
        VariableDeclaration();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void EventDeclaration() throws ParseException {
 /*@bgen(jjtree) EventDeclaration */
  ASTEventDeclaration jjtn000 = new ASTEventDeclaration(JJTEVENTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIM:
      case FRIEND:
      case GLOBAL:
      case PRIVATE:
      case PUBLIC:
      case STATIC:
        ModScopeDecl();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(EVENT);
      Name();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        FormalParamList();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void TypeDeclaration() throws ParseException {
 /*@bgen(jjtree) TypeDeclaration */
  ASTTypeDeclaration jjtn000 = new ASTTypeDeclaration(JJTTYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIM:
      case FRIEND:
      case GLOBAL:
      case PRIVATE:
      case PUBLIC:
      case STATIC:
        ModScopeDecl();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      jj_consume_token(TYPE);
      Name();
      Eos();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          AnyVariableDeclaration();
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        Eos();
        if (jj_2_11(2)) {
          ;
        } else {
          break label_9;
        }
      }
      jj_consume_token(END);
      jj_consume_token(TYPE);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void EnumDeclaration() throws ParseException {
 /*@bgen(jjtree) EnumDeclaration */
  ASTEnumDeclaration jjtn000 = new ASTEnumDeclaration(JJTENUMDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIM:
      case FRIEND:
      case GLOBAL:
      case PRIVATE:
      case PUBLIC:
      case STATIC:
        ModScopeDecl();
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jj_consume_token(ENUM);
      Name();
      Eos();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
        case STEP:
        case IDENTIFIER:
          Name();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASSIGN:
            jj_consume_token(ASSIGN);
            Expression();
            break;
          default:
            jj_la1[23] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[24] = jj_gen;
          ;
        }
        Eos();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EOL:
        case PROPERTY:
        case STEP:
        case IDENTIFIER:
        case COLON:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_10;
        }
      }
      jj_consume_token(END);
      jj_consume_token(ENUM);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void DefModeStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DEFMODE);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(MINUS);
      jj_consume_token(IDENTIFIER);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_11;
        }
        jj_consume_token(COMMA);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(MINUS);
        jj_consume_token(IDENTIFIER);
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ImplementsDecl() throws ParseException {
 /*@bgen(jjtree) Implements */
  ASTImplements jjtn000 = new ASTImplements(JJTIMPLEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IMPLEMENTS);
      TypeName();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ModScopeDecl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PUBLIC:
      jj_consume_token(PUBLIC);
      break;
    case PRIVATE:
      jj_consume_token(PRIVATE);
      break;
    case FRIEND:
      jj_consume_token(FRIEND);
      break;
    case DIM:
      jj_consume_token(DIM);
      break;
    case GLOBAL:
      jj_consume_token(GLOBAL);
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
  }

// ==============================================================================================================================
/**
**  The following are top-level productions for Subs, Functions and Properties
*/
  final public ASTProcDeclaration ProcDeclaration() throws ParseException {
 /*@bgen(jjtree) ProcDeclaration */
  ASTProcDeclaration jjtn000 = new ASTProcDeclaration(JJTPROCDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_12(3)) {
        SubDeclaration();
                                              jjtn000.setProcType(SUB);
      } else if (jj_2_13(3)) {
        FunctionDeclaration();
                                              jjtn000.setProcType(FUNCTION);
      } else if (jj_2_14(4)) {
        PropertyDeclaration();
                                              jjtn000.setProcType(PROPERTY);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void SubDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIM:
    case FRIEND:
    case GLOBAL:
    case PRIVATE:
    case PUBLIC:
    case STATIC:
      ModScopeDecl();
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    jj_consume_token(SUB);
    Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      FormalParamList();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    Eos();
    Statements();
    jj_consume_token(END);
    jj_consume_token(SUB);
  }

  final public void FunctionDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIM:
    case FRIEND:
    case GLOBAL:
    case PRIVATE:
    case PUBLIC:
    case STATIC:
      ModScopeDecl();
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    jj_consume_token(FUNCTION);
    Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      FormalParamList();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      TypeName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    Eos();
    Statements();
    jj_consume_token(END);
    jj_consume_token(FUNCTION);
  }

  final public void PropertyDeclaration() throws ParseException {
    if (jj_2_15(3)) {
      PropertyGetDeclaration();
    } else if (jj_2_16(3)) {
      PropertyLetDeclaration();
    } else if (jj_2_17(3)) {
      PropertySetDeclaration();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PropertyGetDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIM:
    case FRIEND:
    case GLOBAL:
    case PRIVATE:
    case PUBLIC:
    case STATIC:
      ModScopeDecl();
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(PROPERTY);
    jj_consume_token(GET);
    Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      FormalParamList();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      TypeName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    Eos();
    Statements();
    jj_consume_token(END);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PROPERTY:
      jj_consume_token(PROPERTY);
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PropertyLetDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIM:
    case FRIEND:
    case GLOBAL:
    case PRIVATE:
    case PUBLIC:
    case STATIC:
      ModScopeDecl();
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    jj_consume_token(PROPERTY);
    jj_consume_token(LET);
    Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      FormalParamList();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    Eos();
    Statements();
    jj_consume_token(END);
    jj_consume_token(PROPERTY);
  }

  final public void PropertySetDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIM:
    case FRIEND:
    case GLOBAL:
    case PRIVATE:
    case PUBLIC:
    case STATIC:
      ModScopeDecl();
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    jj_consume_token(PROPERTY);
    jj_consume_token(SET);
    Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      FormalParamList();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    Eos();
    Statements();
    jj_consume_token(END);
    jj_consume_token(PROPERTY);
  }

  final public void FormalParamList() throws ParseException {
 /*@bgen(jjtree) FormalParamList */
  ASTFormalParamList jjtn000 = new ASTFormalParamList(JJTFORMALPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BYREF:
      case BYVAL:
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case OPEN:
      case OPTIONAL:
      case PARAMARRAY:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TYPE:
      case TYPEOF:
      case IDENTIFIER:
        ParamSpec();
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[45] = jj_gen;
            break label_12;
          }
          jj_consume_token(COMMA);
          ParamSpec();
        }
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ParamSpec() throws ParseException {
 /*@bgen(jjtree) ParamSpec */
  ASTParamSpec jjtn000 = new ASTParamSpec(JJTPARAMSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPTIONAL:
        jj_consume_token(OPTIONAL);
                                jjtn000.setOptional(true);
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BYREF:
      case BYVAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BYVAL:
          jj_consume_token(BYVAL);
                jjtn000.setByVal(true);
          break;
        case BYREF:
          jj_consume_token(BYREF);
                                                      jjtn000.setByRef(true);
          break;
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAMARRAY:
        jj_consume_token(PARAMARRAY);
                     jjtn000.setParamArray(true);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
      AnyName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        TypeName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          jj_consume_token(STAR);
          Expression();
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        Expression();
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

// ==============================================================================================================================
/**
**  The following are the productions for the procedure-level statements.
*/

    /*
    **  The Statements production has been changed from
    **      ( Statement() )*
    **  to
    **      ( LOOKAHEAD(0, {!isEndBlock()) Statement() )*
    **  This eliminates problems I had with nested semantic / syntactic lookahead
    **  and also makes it easier to provide error recovery.
    **
    **
    **
    **
    **  Most of VB's syntax is fairly simple, and similar to the syntax for C, Pascal
    **  etc. However there are a few legacy statements that have a more COBOL-like syntax, e.g.:
    **      Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength]
    **      object.Line [Step] (x1, y1) [Step] - (x2, y2), [color], [B][F]
    **      Name oldpathname As newpathname
    **  These legacy statements complicate the parsing process. Worse, they complicate
    **  the parsing of the simple statements since complex lookahead is required to
    **  determine that a statement is NOT a legacy statement. For example, compare statements:
    **
    **      SomeObject.SomeFunction("Param1", 2 + 3).Line (SomeOtherFunc(VarName) + 1) * 2
    **      SomeObject.SomeFunction("Param1", 2 + 3).Line (SomeOtherFunc(VarName), 12) - (24, 48)
    **                                                                           ^^^^^^^^^^^^^^^^
    **  The first statement is a simple call of a method called "Line".
    **  The second statement is the legacy "Line" statement.
    **  The parser does not know it is processing a legacy statement until it hits the
    **  comma token as marked by the arrows.
    **
    **  To localise the complexities I use the following scheme:
    **
    **      Save the state of the token stream.
    **      First attempt to parse the statement as a "simple" statement.
    **      If a ParseException occurs
    **          Reset the token stream to its saved value.
    **          Attempt to parse as a Special (legacy) statement.
    **
    **  This is a type of parser backtracking (as opposed to Lookahead backtracking).
    */
  final public ASTStatements Statements() throws ParseException {
 /*@bgen(jjtree) Statements */
    ASTStatements jjtn000 = new ASTStatements(JJTSTATEMENTS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token startToken;
    int originalArity;
    try {
      label_13:
      while (true) {
        if (!isEndBlock()) {
          ;
        } else {
          break label_13;
        }
              startToken = getToken(0); originalArity = jjtree.nodeArity();
        try {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case EOL:
          case COLON:
            Eos();
            break;
          default:
            jj_la1[55] = jj_gen;
            Statement();
            Eos();
          }
        } catch (ParseException e) {
                try
                {
                    // Attempt special case processing

                    // First reset the tokens back to the start of the statement.
                    jj_ntk = -1;
                    token = startToken;

                    // An ASTStatement node may have been pushed on JJTree's stack (depending
                    // on if the Statement() or Eos() call failed).

                    while (jjtree.nodeArity() > originalArity)
                        jjtree.popNode();

                    SpecialStatement();
                    Eos();
                }
                catch (ParseException failedSpecial)
                {

                  if (!attemptErrorRecovery)
                       {if (true) throw(e);}


                  Token t = getToken(1);

                  handleParseError(failedSpecial);

                  ASTUnrecognisedStatement urs = new ASTUnrecognisedStatement(JJTUNRECOGNISEDSTATEMENT);
                  urs.setFirstToken(t);
                  urs.setLastToken(getToken(0));

                  jjtree.pushNode(urs);
                }
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
    throw new Error("Missing return statement in function");
  }

// A dummy production to force JJTree to generate a ASTUnrecognisedStatement.
  final public void Dummy1() throws ParseException {
 /*@bgen(jjtree) UnrecognisedStatement */
  ASTUnrecognisedStatement jjtn000 = new ASTUnrecognisedStatement(JJTUNRECOGNISEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DOT);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public ASTStatement Statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATEMENT_LABEL:
      LabelStatement();
      break;
    case DEBUG_PRINT:
    case DEBUG_ASSERT:
      DebugStatement();
      break;
    default:
      jj_la1[56] = jj_gen;
      if (jj_2_18(2147483647)) {
        EndStatement();
      } else if (jj_2_19(1)) {
          ASTStatement jjtn001 = new ASTStatement(JJTSTATEMENT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        try {
          if (isIdentifier("Attribute")) {

          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(IDENTIFIER);
          PrimaryExpression();
          jj_consume_token(ASSIGN);
          Expression();
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
      } else if (jj_2_20(2)) {
        ProcLevelDeclaration();
      } else if (jj_2_21(2)) {
        DeclareStatement();
      } else if (jj_2_22(2)) {
        ConstDeclaration();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LET:
          Let();
          break;
        case SET:
          Set();
          break;
        case ON:
          OnErrorStatement();
          break;
        case GOTO:
          GotoStatement();
          break;
        case IF:
          IfStatement();
          break;
        case DO:
          DoWhile();
          break;
        case WHILE:
          WhileWend();
          break;
        case CALL:
          CallStatement();
          break;
        case EXIT:
          ExitStatement();
          break;
        default:
          jj_la1[57] = jj_gen;
          if (jj_2_23(2)) {
            ForEachStatement();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case FOR:
              ForStatement();
              break;
            case WITH:
              WithStatement();
              break;
            case RESUME:
              ResumeStatement();
              break;
            case SELECT:
              CaseStatement();
              break;
            case REDIM:
              RedimStatement();
              break;
            case PROPERTY:
            case STEP:
            case IDENTIFIER:
            case DOT:
            case BANG:
              PrimaryExprStatement(false);
              break;
            default:
              jj_la1[58] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
               ASTStatement s = (ASTStatement)(jjtree.peekNode());
               if (s.begin != null)
               {

                   s.setLineNumber(s.begin.currentLineNumberLabel);
               }

               {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public ASTStatement SpecialStatement() throws ParseException {
    if (isNameStatement()) {
      NameStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN:
        OpenStatement();
        break;
      default:
        jj_la1[59] = jj_gen;
        if (isIdentifier("Close")) {
          CloseStatement();
        } else if (isIdentifier("Line") && isIdentifier("Input", 2)) {
          LineInputStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case GET:
            GetStatement();
            break;
          case PUT:
            PutStatement();
            break;
          case PROPERTY:
          case STEP:
          case IDENTIFIER:
          case DOT:
          case BANG:
            PrimaryExprStatement(true);
            break;
          default:
            jj_la1[60] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
               ASTStatement s = (ASTStatement)(jjtree.peekNode());
               if (s.begin != null)
               {

                   s.setLineNumber(s.begin.currentLineNumberLabel);
               }

               {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

// This production must be specified in this weird format so that
// we do not have to use LOOKAHEAD (which would mess up the semantic
// lookahead in "PrimaryExpression()"
// This seems to be a restriction in JavaCC.
  final public void PrimaryExprStatement(boolean allowSpecialCases) throws ParseException {
    Token firstToken = getToken(1);
    boolean isSpecial = false;
    PrimaryExpression();
                                  isSpecial = isSpecialMethod(getToken(0).image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
                  ASTAssignment jjtn001 = new ASTAssignment(JJTASSIGNMENT);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
      try {
        Expression();
      } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
      } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                    jjtreeCloseNodeScope(jjtn001);
                  }
      }
      break;
    default:
      jj_la1[61] = jj_gen;
      if (allowSpecialCases && isSpecialMethod(getToken(0).image)) {
                  ASTMethodCall jjtn002 = new ASTMethodCall(JJTMETHODCALL);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
        try {
          skipToEoln();
        } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  1);
                    jjtreeCloseNodeScope(jjtn002);
                  }
        }
      } else {
              ASTMethodCall jjtn003 = new ASTMethodCall(JJTMETHODCALL);
              boolean jjtc003 = true;
              jjtree.openNodeScope(jjtn003);
              jjtreeOpenNodeScope(jjtn003);
        try {
          ArgList();
        } catch (Throwable jjte003) {
              if (jjtc003) {
                jjtree.clearNodeScope(jjtn003);
                jjtc003 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte003 instanceof RuntimeException) {
                {if (true) throw (RuntimeException)jjte003;}
              }
              if (jjte003 instanceof ParseException) {
                {if (true) throw (ParseException)jjte003;}
              }
              {if (true) throw (Error)jjte003;}
        } finally {
              if (jjtc003) {
                jjtree.closeNodeScope(jjtn003,  2);
                jjtreeCloseNodeScope(jjtn003);
              }
        }
      }
    }
        SimpleNode sn = (SimpleNode)(jjtree.peekNode());
        sn.begin = firstToken;
        sn.end = getToken(0);
  }

  final public void LabelStatement() throws ParseException {
 /*@bgen(jjtree) Label */
  ASTLabel jjtn000 = new ASTLabel(JJTLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(STATEMENT_LABEL);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void DebugStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEBUG_PRINT:
        jj_consume_token(DEBUG_PRINT);
        break;
      case DEBUG_ASSERT:
        jj_consume_token(DEBUG_ASSERT);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      skipToEoln();
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void EndStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(END);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

// For LOOKAHEAD only
  final public void IsEndStatement() throws ParseException {
    jj_consume_token(END);
    jj_consume_token(EOL);
  }

  final public void ProcLevelDeclaration() throws ParseException {
 /*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ProcScopeDecl();
      AnyVariableDeclaration();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[63] = jj_gen;
          break label_14;
        }
        jj_consume_token(COMMA);
        AnyVariableDeclaration();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ProcScopeDecl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      jj_consume_token(STATIC);
      break;
    case DIM:
      jj_consume_token(DIM);
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void VariableDeclaration() throws ParseException {
 /*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WITHEVENTS:
        jj_consume_token(WITHEVENTS);
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      Name();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case ADDRESSOF:
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case FALSE:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case NOT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TRUE:
        case TYPE:
        case TYPEOF:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case HASH:
        case DOT:
        case BANG:
        case PLUS:
        case MINUS:
          VariableDimensions();
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        AsTypeClause();
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case FALSE:
        case TRUE:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
          Literal();
          break;
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          AnyName();
          break;
        default:
          jj_la1[69] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void AnyVariableDeclaration() throws ParseException {
 /*@bgen(jjtree) VarDecl */
  ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      AnyName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case ADDRESSOF:
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case FALSE:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case NOT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TRUE:
        case TYPE:
        case TYPEOF:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case HASH:
        case DOT:
        case BANG:
        case PLUS:
        case MINUS:
          VariableDimensions();
          break;
        default:
          jj_la1[71] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        AsTypeClause();
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case FALSE:
        case TRUE:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
          Literal();
          break;
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          AnyName();
          break;
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void AsTypeClause() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEW:
                   ASTUnaryOp jjtn001 = new ASTUnaryOp(JJTUNARYOP);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                   jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(NEW);
        TypeName();
                                      jjtree.closeNodeScope(jjtn001,  1);
                                      jjtc001 = false;
                                      jjtreeCloseNodeScope(jjtn001);
                                      jjtn001.op = "New";
      } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof RuntimeException) {
                     {if (true) throw (RuntimeException)jjte001;}
                   }
                   if (jjte001 instanceof ParseException) {
                     {if (true) throw (ParseException)jjte001;}
                   }
                   {if (true) throw (Error)jjte001;}
      } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  1);
                     jjtreeCloseNodeScope(jjtn001);
                   }
      }
      break;
    case DEFMODE:
    case END:
    case ENDPROPERTY:
    case ENUM:
    case EVENT:
    case GET:
    case LET:
    case NEXT:
    case OPEN:
    case OPTIONAL:
    case PROPERTY:
    case PUT:
    case REM:
    case SET:
    case STEP:
    case TYPE:
    case TYPEOF:
    case IDENTIFIER:
      TypeName();
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void VariableDimensions() throws ParseException {
    VariableDimension();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[77] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
      VariableDimension();
    }
  }

  final public void VariableDimension() throws ParseException {
 /*@bgen(jjtree) VarDim */
  ASTVarDim jjtn000 = new ASTVarDim(JJTVARDIM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TO:
        jj_consume_token(TO);
        Expression();
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void RedimStatement() throws ParseException {
 /*@bgen(jjtree) ReDim */
  ASTReDim jjtn000 = new ASTReDim(JJTREDIM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(REDIM);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRESERVE:
        jj_consume_token(PRESERVE);
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      RedimClause();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[80] = jj_gen;
          break label_16;
        }
        jj_consume_token(COMMA);
        RedimClause();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void RedimClause() throws ParseException {
    PrimaryExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      AsTypeClause();
      break;
    default:
      jj_la1[81] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      jj_consume_token(STAR);
      Literal();
      break;
    default:
      jj_la1[82] = jj_gen;
      ;
    }
  }

  final public void DeclareStatement() throws ParseException {
 /*@bgen(jjtree) Declare */
  ASTDeclare jjtn000 = new ASTDeclare(JJTDECLARE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIM:
      case FRIEND:
      case GLOBAL:
      case PRIVATE:
      case PUBLIC:
      case STATIC:
        ModScopeDecl();
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
      jj_consume_token(DECLARE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUB:
        jj_consume_token(SUB);
        break;
      case FUNCTION:
        jj_consume_token(FUNCTION);
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Name();
      jj_consume_token(LIB);
      Literal();
      if (isIdentifier("Alias")) {
        jj_consume_token(IDENTIFIER);
        Literal();
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        FormalParamList();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        Name();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[86] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ConstDeclaration() throws ParseException {
 /*@bgen(jjtree) ConstDeclaration */
  ASTConstDeclaration jjtn000 = new ASTConstDeclaration(JJTCONSTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIM:
      case FRIEND:
      case GLOBAL:
      case PRIVATE:
      case PUBLIC:
      case STATIC:
        ModScopeDecl();
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
      jj_consume_token(CONST);
      ConstSpec();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[89] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        ConstSpec();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ConstSpec() throws ParseException {
    Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      Name();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case FALSE:
        case TRUE:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
          Literal();
          break;
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          AnyName();
          break;
        default:
          jj_la1[90] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[92] = jj_gen;
      ;
    }
    jj_consume_token(ASSIGN);
    Expression();
  }

  final public void Set() throws ParseException {
 /*@bgen(jjtree) SetStatement */
  ASTSetStatement jjtn000 = new ASTSetStatement(JJTSETSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SET);
      PrimaryExpression();
      jj_consume_token(ASSIGN);
      Expression();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void Let() throws ParseException {
 /*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LET);
      PrimaryExpression();
      jj_consume_token(ASSIGN);
      Expression();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void OnErrorStatement() throws ParseException {
 /*@bgen(jjtree) OnError */
  ASTOnError jjtn000 = new ASTOnError(JJTONERROR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(ON);
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[93] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RESUME:
        jj_consume_token(RESUME);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEXT:
          jj_consume_token(NEXT);
          break;
        default:
          jj_la1[94] = jj_gen;
          ;
        }
        break;
      case GOTO:
        jj_consume_token(GOTO);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROPERTY:
        case STEP:
        case IDENTIFIER:
          Name();
          break;
        case STRING_LITERAL:
        case FALSE:
        case TRUE:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
          Literal();
          break;
        default:
          jj_la1[95] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void GotoStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(GOTO);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROPERTY:
      case STEP:
      case IDENTIFIER:
        Name();
        break;
      case INTEGER_LITERAL:
        jj_consume_token(INTEGER_LITERAL);
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void IfStatement() throws ParseException {
 /*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
      Expression();
      jj_consume_token(THEN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        Eol();
        MultilineIf();
        break;
      default:
        jj_la1[99] = jj_gen;
        if (jj_2_24(1)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLON:
            jj_consume_token(COLON);
            break;
          default:
            jj_la1[98] = jj_gen;
            ;
          }
          InlineIf();
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void InlineIf() throws ParseException {
    Statement();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        ;
        break;
      default:
        jj_la1[100] = jj_gen;
        break label_18;
      }
      jj_consume_token(COLON);
      if (jj_2_25(1)) {
        Statement();
      } else {
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      Statement();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COLON:
          ;
          break;
        default:
          jj_la1[101] = jj_gen;
          break label_19;
        }
        jj_consume_token(COLON);
        if (jj_2_26(1)) {
          Statement();
        } else {
          ;
        }
      }
      break;
    default:
      jj_la1[102] = jj_gen;
      ;
    }
  }

  final public void MultilineIf() throws ParseException {
    Statements();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSEIF:
        ;
        break;
      default:
        jj_la1[103] = jj_gen;
        break label_20;
      }
      jj_consume_token(ELSEIF);
      Expression();
      jj_consume_token(THEN);
      Eos();
      Statements();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      Eos();
      Statements();
      break;
    default:
      jj_la1[104] = jj_gen;
      ;
    }
    jj_consume_token(END);
    jj_consume_token(IF);
  }

  final public void DoWhile() throws ParseException {
 /*@bgen(jjtree) DoWhileStatement */
  ASTDoWhileStatement jjtn000 = new ASTDoWhileStatement(JJTDOWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DO);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNTIL:
      case WHILE:
        DoCondition();
        break;
      default:
        jj_la1[105] = jj_gen;
        ;
      }
      Eos();
      Statements();
      jj_consume_token(LOOP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNTIL:
      case WHILE:
        DoCondition();
        break;
      default:
        jj_la1[106] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void DoCondition() throws ParseException {
 /*@bgen(jjtree) DoCondition */
  ASTDoCondition jjtn000 = new ASTDoCondition(JJTDOCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHILE:
        jj_consume_token(WHILE);
                   jjtn000.conditionWhile = true;
        break;
      case UNTIL:
        jj_consume_token(UNTIL);
                   jjtn000.conditionWhile = false;
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Condition();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void WhileWend() throws ParseException {
 /*@bgen(jjtree) WhileWendStatement */
  ASTWhileWendStatement jjtn000 = new ASTWhileWendStatement(JJTWHILEWENDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      Condition();
      Eos();
      Statements();
      jj_consume_token(WEND);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ForEachStatement() throws ParseException {
 /*@bgen(jjtree) ForEachStatement */
  ASTForEachStatement jjtn000 = new ASTForEachStatement(JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(FOR);
      jj_consume_token(EACH);
      Name();
      jj_consume_token(IN);
      Expression();
      Eos();
      Statements();
      jj_consume_token(NEXT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROPERTY:
      case STEP:
      case IDENTIFIER:
        Name();
        break;
      default:
        jj_la1[108] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ForStatement() throws ParseException {
 /*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(FOR);
      Name();
      jj_consume_token(ASSIGN);
      Expression();
      jj_consume_token(TO);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STEP:
        jj_consume_token(STEP);
        Expression();
        break;
      default:
        jj_la1[109] = jj_gen;
        ;
      }
      Eos();
      Statements();
      jj_consume_token(NEXT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROPERTY:
      case STEP:
      case IDENTIFIER:
        Name();
        break;
      default:
        jj_la1[110] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void WithStatement() throws ParseException {
 /*@bgen(jjtree) WithStatement */
  ASTWithStatement jjtn000 = new ASTWithStatement(JJTWITHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WITH);
      Expression();
      Statements();
      jj_consume_token(END);
      jj_consume_token(WITH);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void ResumeStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(RESUME);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEXT:
      case PROPERTY:
      case STEP:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEXT:
          jj_consume_token(NEXT);
          break;
        case PROPERTY:
        case STEP:
        case IDENTIFIER:
          Name();
          break;
        default:
          jj_la1[111] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[112] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
** An oddity in the case statement. The documentation says that no statements are
** allowed between "Select Case" and the first "Case" clause. In fact, declarations
** ARE allowed before (any) "Case" clause.
*/
  final public void CaseStatement() throws ParseException {
 /*@bgen(jjtree) CaseStatement */
  ASTCaseStatement jjtn000 = new ASTCaseStatement(JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SELECT);
      jj_consume_token(CASE);
      Expression();
      Eos();
      label_21:
      while (true) {
        if (jj_2_27(2)) {
          ;
        } else {
          break label_21;
        }
        CaseClause();
      }
      jj_consume_token(END);
      jj_consume_token(SELECT);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void CaseClause() throws ParseException {
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
      case DIM:
      case STATIC:
      case COLON:
        ;
        break;
      default:
        jj_la1[113] = jj_gen;
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIM:
      case STATIC:
        ProcLevelDeclaration();
        break;
      default:
        jj_la1[114] = jj_gen;
        ;
      }
      Eos();
    }
    jj_consume_token(CASE);
    CaseExprList();
    Statements();
  }

  final public void CaseExprList() throws ParseException {
    CaseExpr();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_23;
      }
      jj_consume_token(COMMA);
      CaseExpr();
    }
  }

  final public void CaseExpr() throws ParseException {
 /*@bgen(jjtree) CaseExpr */
  ASTCaseExpr jjtn000 = new ASTCaseExpr(JJTCASEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IS:
      case LIKE:
      case ASSIGN:
      case GT:
      case LT:
      case LE:
      case GE:
      case NE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IS:
          jj_consume_token(IS);
          break;
        default:
          jj_la1[116] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          jj_consume_token(LT);
          break;
        case GT:
          jj_consume_token(GT);
          break;
        case LE:
          jj_consume_token(LE);
          break;
        case GE:
          jj_consume_token(GE);
          break;
        case ASSIGN:
          jj_consume_token(ASSIGN);
          break;
        case NE:
          jj_consume_token(NE);
          break;
        case LIKE:
          jj_consume_token(LIKE);
          break;
        default:
          jj_la1[117] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        break;
      case STRING_LITERAL:
      case ADDRESSOF:
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case FALSE:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case NOT:
      case OPEN:
      case OPTIONAL:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TRUE:
      case TYPE:
      case TYPEOF:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DATE_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case HASH:
      case DOT:
      case BANG:
      case PLUS:
      case MINUS:
        Expression();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TO:
          jj_consume_token(TO);
          Expression();
          break;
        default:
          jj_la1[118] = jj_gen;
          ;
        }
        break;
      case ELSE:
        jj_consume_token(ELSE);
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void CallStatement() throws ParseException {
 /*@bgen(jjtree) MethodCall */
  ASTMethodCall jjtn000 = new ASTMethodCall(JJTMETHODCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CALL);
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        ArgList();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[120] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

// TODO Comments. Also need tree to differ for func(x, , y),
// func(x, y) and func(, y, z)
  final public void ArgList() throws ParseException {
 /*@bgen(jjtree) ArgList */
  ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_28(2147483647)) {
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[121] = jj_gen;
            break label_24;
          }
          jj_consume_token(COMMA);
        }
        ArgSpec();
      } else {
        ;
      }
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[122] = jj_gen;
          break label_25;
        }
        label_26:
        while (true) {
          jj_consume_token(COMMA);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[123] = jj_gen;
            break label_26;
          }
        }
        ArgSpec();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/*
**  TODO - The [ <TO> Expression() ] clause is used to allow
**      redim Obj.Arr(1 To 4)
**  It might be better to pass in a parameter specifying if we are passing
**  a ReDim clause or a normal Expression.
*/
  final public void ArgSpec() throws ParseException {
 /*@bgen(jjtree) ArgSpec */
  ASTArgSpec jjtn000 = new ASTArgSpec(JJTARGSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BYREF:
      case BYVAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BYVAL:
          jj_consume_token(BYVAL);
          break;
        case BYREF:
          jj_consume_token(BYREF);
          break;
        default:
          jj_la1[124] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[125] = jj_gen;
        ;
      }
      if (jj_2_29(2)) {
        NamedArg();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case ADDRESSOF:
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case FALSE:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case NOT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TRUE:
        case TYPE:
        case TYPEOF:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DATE_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case HASH:
        case DOT:
        case BANG:
        case PLUS:
        case MINUS:
          UnNamedArg();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TO:
            jj_consume_token(TO);
            Expression();
            break;
          default:
            jj_la1[126] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[127] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

// TODO - can have x = SomeObj.SomeMethod(Sub:=12)
// i.e. a parameter named "Sub" (or indeed, "As", "Byval" etc).
// Need to fix this by using a sematic LA for ":=" and a
// JAVACODE production for NamedArg.
  final public void NamedArg() throws ParseException {
    AnyName();
    jj_consume_token(153);
    Expression();
  }

  final public void UnNamedArg() throws ParseException {
    Expression();
  }

  final public void ExitStatement() throws ParseException {
 /*@bgen(jjtree) ExitStatement */
  ASTExitStatement jjtn000 = new ASTExitStatement(JJTEXITSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(EXIT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FUNCTION:
        jj_consume_token(FUNCTION);
        break;
      case PROPERTY:
        jj_consume_token(PROPERTY);
        break;
      case SUB:
        jj_consume_token(SUB);
        break;
      case DO:
        jj_consume_token(DO);
        break;
      case FOR:
        jj_consume_token(FOR);
        break;
      case WHILE:
        jj_consume_token(WHILE);
        break;
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void TypeName() throws ParseException {
 /*@bgen(jjtree) TypeName */
  ASTTypeName jjtn000 = new ASTTypeName(JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      AnyName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        AnyName();
        break;
      default:
        jj_la1[129] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

/**
**   Name() and AnyName()
**   ====================
**
** VB does not allow reserved words (such as "New") to be used
** as identifiers. E.g. these are not valid:
**
**      Dim New As Integer      // INVALID
**      Open = 66               // INVALID
**
** However it does permit the names of member variables/methods
** in expressions etc to be reserved words (presumably this is because
** an object may have been created in a language other than VB, and that
** language may have different keywords). Therefore these are valid:
**
**      X = Obj.Sub.If
**      Public Type YY
**          Sub As Integer
**      End
**
** NB: To confuse things even further, there are some keywords such as
** "Name" which can also be used as the names of variables, e.g.
**
**      Name "Thing.txt" As "Thing.bak"
**      Dim Name as String
**      Name = "X"
**
** The "Name()" production lists all names that can be used directly
** as variable, i.e. that can appear in a "Dim" statement, or can appear
** on the RHS
*/
  final public void Name() throws ParseException {
 /*@bgen(jjtree) Name */
  ASTName jjtn000 = new ASTName(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case PROPERTY:
        jj_consume_token(PROPERTY);
        break;
      case STEP:
        jj_consume_token(STEP);
        break;
      default:
        jj_la1[130] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
        jjtn000.setName(getToken(0).image);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void AnyName() throws ParseException {
 /*@bgen(jjtree) #Name( jjtree . nodeArity ( ) == 0) */
  ASTName jjtn000 = new ASTName(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROPERTY:
      case STEP:
      case IDENTIFIER:
        Name();
        break;
      case DEFMODE:
        jj_consume_token(DEFMODE);
        break;
      case ENUM:
        jj_consume_token(ENUM);
        break;
      case EVENT:
        jj_consume_token(EVENT);
        break;
      case GET:
        jj_consume_token(GET);
        break;
      case LET:
        jj_consume_token(LET);
        break;
      case NEW:
        jj_consume_token(NEW);
        break;
      case OPEN:
        jj_consume_token(OPEN);
        break;
      case OPTIONAL:
        jj_consume_token(OPTIONAL);
        break;
      case NEXT:
        jj_consume_token(NEXT);
        break;
      case PUT:
        jj_consume_token(PUT);
        break;
      case SET:
        jj_consume_token(SET);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        break;
      case TYPEOF:
        jj_consume_token(TYPEOF);
        break;
      case END:
        jj_consume_token(END);
        break;
      case ENDPROPERTY:
        jj_consume_token(ENDPROPERTY);
        break;
      case REM:
        jj_consume_token(REM);
        break;
      default:
        jj_la1[131] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) == 0);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
        jjtn000.setName(getToken(0).image);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  jjtree . nodeArity ( ) == 0);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

// Conditions are the same as expressions.
  final public void Condition() throws ParseException {
    Expression();
  }

/*
 * Expression syntax follows.
 */
  final public ASTExpression Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      ImpExpression();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void ImpExpression() throws ParseException {
    EqvExpression();
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMP:
        ;
        break;
      default:
        jj_la1[132] = jj_gen;
        break label_27;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(IMP);
                  jjtn001.op = getToken(0).image;
        EqvExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void EqvExpression() throws ParseException {
    XorExpression();
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQV:
        ;
        break;
      default:
        jj_la1[133] = jj_gen;
        break label_28;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(EQV);
                  jjtn001.op = getToken(0).image;
        XorExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void XorExpression() throws ParseException {
    OrExpression();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[134] = jj_gen;
        break label_29;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(XOR);
                  jjtn001.op = getToken(0).image;
        OrExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void OrExpression() throws ParseException {
    AndExpression();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[135] = jj_gen;
        break label_30;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(OR);
                 jjtn001.op = getToken(0).image;
        AndExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void AndExpression() throws ParseException {
    ComparisonOpExpression();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[136] = jj_gen;
        break label_31;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(AND);
                  jjtn001.op = getToken(0).image;
        ComparisonOpExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void ComparisonOpExpression() throws ParseException {
    StringConcatExpression();
    label_32:
    while (true) {
      if (jj_2_30(2)) {
        ;
      } else {
        break label_32;
      }
                       ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                       jjtreeOpenNodeScope(jjtn001);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
          jj_consume_token(ASSIGN);
          break;
        case LT:
          jj_consume_token(LT);
          break;
        case GT:
          jj_consume_token(GT);
          break;
        case LE:
          jj_consume_token(LE);
          break;
        case GE:
          jj_consume_token(GE);
          break;
        case NE:
          jj_consume_token(NE);
          break;
        case IS:
          jj_consume_token(IS);
          break;
        case LIKE:
          jj_consume_token(LIKE);
          break;
        default:
          jj_la1[137] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
              jjtn001.op = getToken(0).image;
        StringConcatExpression();
      } catch (Throwable jjte001) {
                       if (jjtc001) {
                         jjtree.clearNodeScope(jjtn001);
                         jjtc001 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte001 instanceof RuntimeException) {
                         {if (true) throw (RuntimeException)jjte001;}
                       }
                       if (jjte001 instanceof ParseException) {
                         {if (true) throw (ParseException)jjte001;}
                       }
                       {if (true) throw (Error)jjte001;}
      } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                         jjtreeCloseNodeScope(jjtn001);
                       }
      }
    }
  }

  final public void StringConcatExpression() throws ParseException {
    AdditiveExpression();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[138] = jj_gen;
        break label_33;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(BIT_AND);
                jjtn001.op = getToken(0).image;
        AdditiveExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void AdditiveExpression() throws ParseException {
    MultiplicativeExpression();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[139] = jj_gen;
        break label_34;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        default:
          jj_la1[140] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                          jjtn001.op = getToken(0).image;
        MultiplicativeExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void MultiplicativeExpression() throws ParseException {
    ExpoExpression();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOD:
      case STAR:
      case SLASH:
      case BACKSLASH:
        ;
        break;
      default:
        jj_la1[141] = jj_gen;
        break label_35;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          jj_consume_token(STAR);
          break;
        case SLASH:
          jj_consume_token(SLASH);
          break;
        case BACKSLASH:
          jj_consume_token(BACKSLASH);
          break;
        case MOD:
          jj_consume_token(MOD);
          break;
        default:
          jj_la1[142] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                        jjtn001.op = getToken(0).image;
        ExpoExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void ExpoExpression() throws ParseException {
    DotOpExpression();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPO:
        ;
        break;
      default:
        jj_la1[143] = jj_gen;
        break label_36;
      }
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(EXPO);
                    jjtn001.op = getToken(0).image;
        DotOpExpression();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
    }
  }

  final public void DotOpExpression() throws ParseException {
    UnaryOps();
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case BANG:
        ;
        break;
      default:
        jj_la1[144] = jj_gen;
        break label_37;
      }
        ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
        boolean jjtc001 = true;
        jjtree.openNodeScope(jjtn001);
        jjtreeOpenNodeScope(jjtn001);
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
                jjtn001.op = getToken(0).image;
          DotOperand();
          break;
        case BANG:
          jj_consume_token(BANG);
                jjtn001.op = getToken(0).image;
          BangOperand();
          break;
        default:
          jj_la1[145] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Throwable jjte001) {
        if (jjtc001) {
          jjtree.clearNodeScope(jjtn001);
          jjtc001 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte001 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte001;}
        }
        if (jjte001 instanceof ParseException) {
          {if (true) throw (ParseException)jjte001;}
        }
        {if (true) throw (Error)jjte001;}
      } finally {
        if (jjtc001) {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtreeCloseNodeScope(jjtn001);
        }
      }
    }
  }

  void BangOperand() throws ParseException {
 /*@bgen(jjtree) Name */
 ASTName jjtn000 = new ASTName(JJTNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
 try {if (getToken(1).image.equals("["))
    {
        while (!getToken(0).image.equals("]"))
            getNextToken();
    }
    else if (getToken(1).kind != EOL)
    {
        getAnyToken();
    }
    else
        throw new ParseException("Expected operand after \"!\"");/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
 }
  }

  final public void DotOperand() throws ParseException {
    if (jj_2_31(2)) {
      FuncCall();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case OPEN:
      case OPTIONAL:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TYPE:
      case TYPEOF:
      case IDENTIFIER:
        AnyName();
        break;
      default:
        jj_la1[146] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void UnaryOps() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
          ASTUnaryOp jjtn001 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(DOT);
                          jjtn001.op = getToken(0).image;
        ExpTerminal();
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
      break;
    case BANG:
          ASTUnaryOp jjtn002 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
          jjtreeOpenNodeScope(jjtn002);
      try {
        jj_consume_token(BANG);
                          jjtn002.op = getToken(0).image;
        BangOperand();
      } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002,  1);
            jjtreeCloseNodeScope(jjtn002);
          }
      }
      break;
    case NEW:
                       ASTUnaryOp jjtn003 = new ASTUnaryOp(JJTUNARYOP);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                       jjtreeOpenNodeScope(jjtn003);
      try {
        jj_consume_token(NEW);
                                      jjtn003.op = getToken(0).image;
        UnaryOps();
      } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof RuntimeException) {
                         {if (true) throw (RuntimeException)jjte003;}
                       }
                       if (jjte003 instanceof ParseException) {
                         {if (true) throw (ParseException)jjte003;}
                       }
                       {if (true) throw (Error)jjte003;}
      } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003,  1);
                         jjtreeCloseNodeScope(jjtn003);
                       }
      }
      break;
    case PLUS:
          ASTUnaryOp jjtn004 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
          jjtreeOpenNodeScope(jjtn004);
      try {
        jj_consume_token(PLUS);
                          jjtn004.op = getToken(0).image;
        ExpoExpression();
      } catch (Throwable jjte004) {
          if (jjtc004) {
            jjtree.clearNodeScope(jjtn004);
            jjtc004 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte004 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte004;}
          }
          if (jjte004 instanceof ParseException) {
            {if (true) throw (ParseException)jjte004;}
          }
          {if (true) throw (Error)jjte004;}
      } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004,  1);
            jjtreeCloseNodeScope(jjtn004);
          }
      }
      break;
    case MINUS:
          ASTUnaryOp jjtn005 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
          jjtreeOpenNodeScope(jjtn005);
      try {
        jj_consume_token(MINUS);
                          jjtn005.op = getToken(0).image;
        ExpoExpression();
      } catch (Throwable jjte005) {
          if (jjtc005) {
            jjtree.clearNodeScope(jjtn005);
            jjtc005 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte005 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte005;}
          }
          if (jjte005 instanceof ParseException) {
            {if (true) throw (ParseException)jjte005;}
          }
          {if (true) throw (Error)jjte005;}
      } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005,  1);
            jjtreeCloseNodeScope(jjtn005);
          }
      }
      break;
    case NOT:
          ASTUnaryOp jjtn006 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
          jjtreeOpenNodeScope(jjtn006);
      try {
        jj_consume_token(NOT);
                          jjtn006.op = getToken(0).image;
        ComparisonOpExpression();
      } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte006;}
          }
          if (jjte006 instanceof ParseException) {
            {if (true) throw (ParseException)jjte006;}
          }
          {if (true) throw (Error)jjte006;}
      } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006,  1);
            jjtreeCloseNodeScope(jjtn006);
          }
      }
      break;
    case TYPEOF:
                       ASTUnaryOp jjtn007 = new ASTUnaryOp(JJTUNARYOP);
                       boolean jjtc007 = true;
                       jjtree.openNodeScope(jjtn007);
                       jjtreeOpenNodeScope(jjtn007);
      try {
        jj_consume_token(TYPEOF);
                                      jjtn007.op = getToken(0).image;
        UnaryOps();
      } catch (Throwable jjte007) {
                       if (jjtc007) {
                         jjtree.clearNodeScope(jjtn007);
                         jjtc007 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte007 instanceof RuntimeException) {
                         {if (true) throw (RuntimeException)jjte007;}
                       }
                       if (jjte007 instanceof ParseException) {
                         {if (true) throw (ParseException)jjte007;}
                       }
                       {if (true) throw (Error)jjte007;}
      } finally {
                       if (jjtc007) {
                         jjtree.closeNodeScope(jjtn007,  1);
                         jjtreeCloseNodeScope(jjtn007);
                       }
      }
      break;
    case ADDRESSOF:
          ASTUnaryOp jjtn008 = new ASTUnaryOp(JJTUNARYOP);
          boolean jjtc008 = true;
          jjtree.openNodeScope(jjtn008);
          jjtreeOpenNodeScope(jjtn008);
      try {
        jj_consume_token(ADDRESSOF);
                          jjtn008.op = getToken(0).image;
        UnaryOps();
      } catch (Throwable jjte008) {
          if (jjtc008) {
            jjtree.clearNodeScope(jjtn008);
            jjtc008 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte008 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte008;}
          }
          if (jjte008 instanceof ParseException) {
            {if (true) throw (ParseException)jjte008;}
          }
          {if (true) throw (Error)jjte008;}
      } finally {
          if (jjtc008) {
            jjtree.closeNodeScope(jjtn008,  1);
            jjtreeCloseNodeScope(jjtn008);
          }
      }
      break;
    case STRING_LITERAL:
    case DEFMODE:
    case END:
    case ENDPROPERTY:
    case ENUM:
    case EVENT:
    case FALSE:
    case GET:
    case LET:
    case NEXT:
    case OPEN:
    case OPTIONAL:
    case PROPERTY:
    case PUT:
    case REM:
    case SET:
    case STEP:
    case TRUE:
    case TYPE:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DATE_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case HASH:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HASH:
        jj_consume_token(HASH);
        break;
      default:
        jj_la1[147] = jj_gen;
        ;
      }
      ExpTerminal();
      break;
    default:
      jj_la1[148] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ExpTerminal() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
    case FALSE:
    case TRUE:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOATING_POINT_LITERAL:
    case DATE_LITERAL:
      Literal();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[149] = jj_gen;
      if (jj_2_32(2)) {
        FuncCall();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFMODE:
        case END:
        case ENDPROPERTY:
        case ENUM:
        case EVENT:
        case GET:
        case LET:
        case NEW:
        case NEXT:
        case OPEN:
        case OPTIONAL:
        case PROPERTY:
        case PUT:
        case REM:
        case SET:
        case STEP:
        case TYPE:
        case TYPEOF:
        case IDENTIFIER:
          AnyName();
          break;
        default:
          jj_la1[150] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void FuncCall() throws ParseException {
    AnyName();
    label_38:
    while (true) {
          ASTBinOp jjtn001 = new ASTBinOp(JJTBINOP);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
      try {
        jj_consume_token(LPAREN);
                jjtn001.op = "()";
        ArgList();
        jj_consume_token(RPAREN);
      } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
      } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtreeCloseNodeScope(jjtn001);
          }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[151] = jj_gen;
        break label_38;
      }
    }
  }

  final public void SpecialFuncCall() throws ParseException {
     System.out.println("SpecialFuncCall");
    skipToEoln();
  }

/**
**  A primary expression is formed from Expression Terminals (literals,
**  function calls, variable names and parenthesized sub-expressions), all
**  potentially linked together by the binary "." and "!" operators.
**  E.g.
**      Obj.SubObj.Method1
**  or
**      Obj.Func("Param1", 4 + 5).Value
**  or plain
**  MethodName
*/
  final public void PrimaryExpression() throws ParseException {
 /*@bgen(jjtree) PrimaryExpression */
  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case BANG:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        default:
          jj_la1[152] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        PrimaryName();
        PrimarySuffix();
        break;
      case PROPERTY:
      case STEP:
      case IDENTIFIER:
        Name();
        PrimarySuffix();
        break;
      default:
        jj_la1[153] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
        }
    }
  }

  final public void PrimarySuffix() throws ParseException {
    label_39:
    while (true) {
      if (isBinarySuffix()) {
        ;
      } else {
        break label_39;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case BANG:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          jj_consume_token(DOT);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        default:
          jj_la1[154] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        PrimaryName();
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        ArgList();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void PrimaryName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFMODE:
    case END:
    case ENDPROPERTY:
    case ENUM:
    case EVENT:
    case GET:
    case LET:
    case NEW:
    case NEXT:
    case OPEN:
    case OPTIONAL:
    case PROPERTY:
    case PUT:
    case REM:
    case SET:
    case STEP:
    case TYPE:
    case TYPEOF:
    case IDENTIFIER:
      AnyName();
      break;
    default:
      jj_la1[156] = jj_gen;
      BangOperand();
    }
  }

  final public void Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        jj_consume_token(INTEGER_LITERAL);
        break;
      case LONG_LITERAL:
        jj_consume_token(LONG_LITERAL);
        break;
      case FLOATING_POINT_LITERAL:
        jj_consume_token(FLOATING_POINT_LITERAL);
        break;
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        break;
      case DATE_LITERAL:
        jj_consume_token(DATE_LITERAL);
        break;
      case TRUE:
        jj_consume_token(TRUE);
        break;
      case FALSE:
        jj_consume_token(FALSE);
        break;
      default:
        jj_la1[157] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void Arguments() throws ParseException {
 /*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = new ASTArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
      case ADDRESSOF:
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case FALSE:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case NOT:
      case OPEN:
      case OPTIONAL:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TRUE:
      case TYPE:
      case TYPEOF:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DATE_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case HASH:
      case DOT:
      case BANG:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        jj_la1[158] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ArgumentList() throws ParseException {
    Expression();
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[159] = jj_gen;
        break label_40;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }

// ==============================================================================================================================
/**
**  The following are "oddities" in the VB language -- the "Put #" statement etc
*/
  final public void LineInputStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      jj_consume_token(IDENTIFIER);
      if (jj_2_33(2)) {
        jj_consume_token(HASH);
      } else {
        ;
      }
      Expression();
      jj_consume_token(COMMA);
      AnyName();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void GetStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(GET);
      Expression();
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
      case ADDRESSOF:
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case FALSE:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case NOT:
      case OPEN:
      case OPTIONAL:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TRUE:
      case TYPE:
      case TYPEOF:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DATE_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case HASH:
      case DOT:
      case BANG:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        jj_la1[160] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        Expression();
        break;
      default:
        jj_la1[161] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void PutStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(PUT);
      Expression();
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
      case ADDRESSOF:
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case FALSE:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case NOT:
      case OPEN:
      case OPTIONAL:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TRUE:
      case TYPE:
      case TYPEOF:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DATE_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case HASH:
      case DOT:
      case BANG:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        jj_la1[162] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        Expression();
        break;
      default:
        jj_la1[163] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void NameStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      Expression();
      jj_consume_token(AS);
      Expression();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void OpenStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(OPEN);
      Expression();
      jj_consume_token(FOR);
      jj_consume_token(IDENTIFIER);
      if (isIdentifier("Access")) {
        jj_consume_token(IDENTIFIER);
        jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[164] = jj_gen;
          ;
        }
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOCK:
      case SHARED:
        LockClause();
        break;
      default:
        jj_la1[165] = jj_gen;
        ;
      }
      jj_consume_token(AS);
      Expression();
      if (isIdentifier("Len")) {
        jj_consume_token(IDENTIFIER);
        jj_consume_token(ASSIGN);
        Expression();
      } else {
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void LockClause() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SHARED:
      jj_consume_token(SHARED);
      break;
    case LOCK:
      jj_consume_token(LOCK);
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[166] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[167] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void CloseStatement() throws ParseException {
 /*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
      case ADDRESSOF:
      case DEFMODE:
      case END:
      case ENDPROPERTY:
      case ENUM:
      case EVENT:
      case FALSE:
      case GET:
      case LET:
      case NEW:
      case NEXT:
      case NOT:
      case OPEN:
      case OPTIONAL:
      case PROPERTY:
      case PUT:
      case REM:
      case SET:
      case STEP:
      case TRUE:
      case TYPE:
      case TYPEOF:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOATING_POINT_LITERAL:
      case DATE_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case HASH:
      case DOT:
      case BANG:
      case PLUS:
      case MINUS:
        FileNumberList();
        break;
      default:
        jj_la1[168] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }

  final public void FileNumberList() throws ParseException {
    Expression();
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[169] = jj_gen;
        break label_41;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }

// ==============================================================================================================================



/**
** Consume at least one End-of-line character.
** NB: A java code loop is used here, as a convenient way to prevent
** ambiguities involving end-of-line in other
** statements.
*/
  final public void Eol() throws ParseException {
    jj_consume_token(EOL);
        while (getToken(1).kind == EOL)
        {
            getNextToken();
        }
  }

  final public void Eos() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOL:
      Eol();
      break;
    case COLON:
      jj_consume_token(COLON);
      break;
    default:
      jj_la1[170] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  void skipToEoln() throws ParseException {
    while (getToken(1).kind != EOL && getToken(1).kind != COLON)
    {
        getNextToken();
    }
  }

  void Identifier(String id) throws ParseException {
      if (!getToken(1).image.equalsIgnoreCase(id))
        throw generateParseException();

      getNextToken();
  }

  void error_skipto(int kind) throws ParseException {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
  }

  void error_skiptobefore(int kind) throws ParseException {
  while (getToken(1).kind != kind)
    getNextToken();
  }

// Test procedure for PrimaryExprStatement
  final public void TestPrimaryExprStatement() throws ParseException {
    Statements();
    jj_consume_token(0);
            ((SimpleNode)jjtree.peekNode()).dump(">");
  }

  void SkipSpecialFunction() throws ParseException {
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) return true;
    }
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) return true;
    }
    return false;
  }

  final private boolean jj_3_28() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(130)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_224() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(130)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_218() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_224()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_225()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_scan_token(CALL)) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_192() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_218()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) return true;
    }
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(61)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(136)) {
    jj_scanpos = xsp;
    if (jj_scan_token(135)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(134)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_151() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(137)) return true;
    }
    if (jj_3R_181()) return true;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_3R_151()) return true;
    return false;
  }

  final private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) return true;
    }
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_182() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_193()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_113()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_78()) return true;
    if (jj_3R_182()) return true;
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_162() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(137)) return true;
    }
    if (jj_3R_181()) return true;
    if (jj_3R_182()) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) return true;
    }
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(SELECT)) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(RESUME)) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_scan_token(AS)) return true;
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_scan_token(BYREF)) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_218()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(WITH)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_117()) return true;
    Token xsp;
    if (jj_3R_119()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_119()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_230() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3_32() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_229() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_125()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_3R_185()) return true;
    return false;
  }

  final private boolean jj_3R_221() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  final private boolean jj_3R_213() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(131)) jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_scan_token(ADDRESSOF)) return true;
    if (jj_3R_196()) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(AS)) return true;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_scan_token(TYPEOF)) return true;
    if (jj_3R_196()) return true;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_226()) return true;
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_171()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(EACH)) return true;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_171()) return true;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_196()) return true;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(BANG)) return true;
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) {
    jj_scanpos = xsp;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_scan_token(PARAMARRAY)) return true;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_scan_token(BYVAL)) return true;
    return false;
  }

  final private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) return true;
    }
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_scan_token(OPTIONAL)) return true;
    return false;
  }

  final private boolean jj_3R_197() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_215()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_scan_token(DO)) return true;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_197()) return true;
    return false;
  }

  final private boolean jj_3R_239() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) return true;
    }
    return false;
  }

  final private boolean jj_3_31() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) jj_scanpos = xsp;
    if (jj_scan_token(PROPERTY)) return true;
    if (jj_scan_token(SET)) return true;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_168()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_92()) jj_scanpos = xsp;
    if (jj_scan_token(PROPERTY)) return true;
    if (jj_scan_token(LET)) return true;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_167()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(140)) jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_238() {
    if (jj_scan_token(BANG)) return true;
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  final private boolean jj_3R_237() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_239()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) jj_scanpos = xsp;
    if (jj_scan_token(PROPERTY)) return true;
    if (jj_scan_token(GET)) return true;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_165()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  final private boolean jj_3R_236() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_237()) {
    jj_scanpos = xsp;
    if (jj_3R_238()) return true;
    }
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_56()) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_55()) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(GOTO)) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3_17()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_3R_196()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_236()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_scan_token(ON)) return true;
    return false;
  }

  final private boolean jj_3R_235() {
    if (jj_scan_token(EXPO)) return true;
    if (jj_3R_184()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) jj_scanpos = xsp;
    if (jj_scan_token(FUNCTION)) return true;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_89()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_3R_184()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_235()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_scan_token(LET)) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) jj_scanpos = xsp;
    if (jj_scan_token(SUB)) return true;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_87()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_234() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(146)) {
    jj_scanpos = xsp;
    if (jj_scan_token(147)) {
    jj_scanpos = xsp;
    if (jj_scan_token(150)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    }
    }
    if (jj_3R_171()) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(AS)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_3R_171()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_234()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_53()) return true;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_233() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(144)) {
    jj_scanpos = xsp;
    if (jj_scan_token(145)) return true;
    }
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_78()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_176()) jj_scanpos = xsp;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_3R_155()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_233()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) jj_scanpos = xsp;
    if (jj_scan_token(CONST)) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_118()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_232()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_175()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) jj_scanpos = xsp;
    if (jj_scan_token(DECLARE)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) return true;
    }
    if (jj_3R_78()) return true;
    if (jj_scan_token(LIB)) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) return true;
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(90)) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  final private boolean jj_3_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(134)) {
    jj_scanpos = xsp;
    if (jj_scan_token(136)) {
    jj_scanpos = xsp;
    if (jj_scan_token(135)) {
    jj_scanpos = xsp;
    if (jj_scan_token(141)) {
    jj_scanpos = xsp;
    if (jj_scan_token(142)) {
    jj_scanpos = xsp;
    if (jj_scan_token(143)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_157()) return true;
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_3R_66()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_30()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  final private boolean jj_3R_231() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_226()) return true;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_3R_185()) return true;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(DEFMODE)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(MINUS)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_scan_token(REDIM)) return true;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_3R_198()) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(STAR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) return true;
    }
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_3R_226()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_231()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_3R_157()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_219()) return true;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) jj_scanpos = xsp;
    if (jj_scan_token(ENUM)) return true;
    if (jj_3R_78()) return true;
    if (jj_3R_50()) return true;
    if (jj_3R_159()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_159()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_3R_185()) return true;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_219()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_227()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_3R_217()) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_77()) jj_scanpos = xsp;
    if (jj_scan_token(TYPE)) return true;
    if (jj_3R_78()) return true;
    if (jj_3R_50()) return true;
    if (jj_3_11()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_203()) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_128()) return true;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) return true;
    }
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(AS)) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) jj_scanpos = xsp;
    if (jj_scan_token(EVENT)) return true;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_158()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_3R_203()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_220()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_scan_token(EQV)) return true;
    if (jj_3R_194()) return true;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(AS)) return true;
    if (jj_3R_188()) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_128()) return true;
    if (jj_3R_160()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_161()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_3R_117()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_130()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_3R_194()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_204()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(OPTION)) return true;
    Token xsp;
    if (jj_3R_156()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_156()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_scan_token(IMP)) return true;
    if (jj_3R_183()) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(102)) jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_3R_178()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_3R_126()) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_183()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_195()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_124()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) return true;
    }
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_123()) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_48()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_47()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_45()) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_94()) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_121()) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_120()) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = isIdentifier("Attribute");
    lookingAhead = false;
    if (!jj_semLA || jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_164()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(END)) return true;
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_scan_token(END)) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) return true;
    }
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(STATEMENT_LABEL)) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_scan_token(140)) return true;
    }
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_126()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).image.equalsIgnoreCase("BEGIN");
    lookingAhead = false;
    if (!jj_semLA || jj_3R_74()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(1).image.equalsIgnoreCase("BEGINPROPERTY");
    lookingAhead = false;
    if (!jj_semLA || jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(TO)) return true;
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_225() {
    Token xsp;
    if (jj_scan_token(130)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(130)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_scan_token(HASH)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_3R_149()) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_3R_148()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_3R_147()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_3R_117()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_145()) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_3R_144()) return true;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_3R_152()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_153()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_58() {
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_3R_142()) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_3R_141()) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_3R_140()) return true;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(EXIT)) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_3R_138()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_3R_137()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_3R_136()) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_135()) return true;
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_3R_48()) return true;
    return false;
  }

  final private boolean jj_3_19() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = isIdentifier("Attribute");
    lookingAhead = false;
    if (!jj_semLA || jj_3R_58()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_3R_133()) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_3R_132()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_117()) return true;
    if (jj_scan_token(153)) return true;
    if (jj_3R_125()) return true;
    return false;
  }

  public VBParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[171];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x4,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0xc0000000,0xc0000000,0x0,0x0,0x0,0x20000000,0x0,0x4,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa000000,0x0,0x20000000,0x2000000,0x0,0xa000000,0x0,0x20000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x2000000,0x0,0x20000000,0x0,0x0,0x2000000,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0xa000000,0x0,0x0,0x0,0x0,0xc0000000,0xc0000000,0x0,0xa000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0xa000000,0x0,0xa000000,0x0,0xa000000,0x0,0x0,0x0,0x0,0x0,0xa000000,0x0,0x4,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xb00080,0x0,0x417040,0x0,0x0,0x0,0x0,0x40000,0x40000,0x0,0x0,0x0,0x8000040,0x900080,0x0,0x457040,0x457040,0x0,0x900080,0x0,0x900080,0x417040,0x900080,0x0,0x0,0x0,0x0,0x0,0x900080,0x0,0x900080,0x0,0x900080,0x0,0x0,0x0,0x900080,0x0,0x0,0x0,0x200000,0x900080,0x0,0x900080,0x0,0x0,0x417040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x3020101,0x80000,0x0,0x400000,0x0,0x18,0x0,0x80,0x0,0x457040,0x0,0x0,0x457040,0x0,0x457040,0x0,0x0,0x457040,0x0,0x417040,0x0,0x0,0x0,0x0,0x0,0x0,0x900080,0x200000,0x0,0x0,0x0,0x900080,0x0,0x457040,0x0,0x0,0x0,0x0,0x40000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x400,0x800,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x0,0x20000000,0x80000000,0x0,0xa0457440,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x457040,0x280100,0x0,0x0,0x417040,0x4000000,0x8000,0x0,0x0,0x0,0xa0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x417040,0x0,0x457040,0x40000,0x417040,0x0,0x0,0x0,0x0,0x0,0x417040,0x40000,0x457040,0x0,0x457040,0x0,0x457040,0x0,0x0,0x0,0x0,0x0,0x457040,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x1402c000,0x0,0x88c8531,0x0,0x8008000,0x0,0x0,0x80000000,0x80000000,0x0,0x8008000,0x0,0x200,0x4024000,0x0,0x888cc531,0x888cc531,0x0,0x4024000,0x0,0x4024000,0x88c8531,0x4024000,0x0,0x8008000,0x8008000,0x0,0x4000000,0x24000,0x4000000,0x4024000,0x0,0x4024000,0x0,0x0,0x0,0x4024000,0x0,0x0,0x0,0x8000,0x4024000,0x0,0x4024000,0x0,0x0,0x88c9531,0x400,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x800081,0x8708000,0x100,0x8048000,0x0,0x0,0x0,0x4000000,0x0,0x888c8571,0x0,0x0,0x888c8531,0x0,0x888c8571,0x0,0x0,0x888c8531,0x0,0x88c8531,0x0,0x40000000,0x2000,0x0,0x0,0x0,0x4024000,0x10000000,0x0,0x0,0x0,0x4024000,0x0,0x888c8531,0x0,0x0,0x0,0x20,0x88008000,0x200000,0x8008000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8008000,0x8000000,0x8008000,0x8008020,0x8008020,0x4000000,0x4000000,0x0,0x0,0x0,0x40000000,0x888c8571,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x888c8571,0x10008000,0x0,0x8008000,0x88c8531,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x88c8531,0x0,0x888c8571,0x80000000,0x88c8531,0x0,0x0,0x8008000,0x0,0x0,0x88c8531,0x80000000,0x888c8571,0x0,0x888c8571,0x0,0x888c8571,0x0,0x0,0x1000002,0x0,0x1000002,0x888c8571,0x0,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x200003,0x20000000,0x200001,0x0,0x0,0x224300,0x224300,0x100000,0x200001,0x0,0x0,0x0,0x0,0x224303,0x224303,0x0,0x0,0x8000000,0x0,0x200003,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x8000000,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x200003,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x10,0x200020,0x0,0x200000,0x0,0x0,0x0,0x0,0x40,0x8224303,0x8000000,0x0,0x224303,0x0,0x8224303,0x8000000,0x0,0x224303,0x0,0x200003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x224303,0x0,0x0,0x200000,0x0,0x224300,0x0,0x200100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14,0x14,0x14,0x200000,0x0,0x200000,0x200000,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x8224303,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x8224303,0x10,0x0,0x200000,0x200003,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200003,0x0,0x8224303,0x8024300,0x200003,0x8000000,0x0,0x200000,0x0,0x8000000,0x200003,0x24300,0x8224303,0x0,0x8224303,0x0,0x8224303,0x0,0x200000,0x0,0x200000,0x0,0x8224303,0x0,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x210,0x820020,0x820020,0x0,0x0,0x0,0x210,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x1000,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x40,0x1000,0x0,0x0,0x210,0x0,0x210,0x40,0x0,0x4,0x0,0x0,0x30218,0x0,0x0,0x0,0x40000,0x30218,0x0,0x0,0x0,0x40000,0x0,0x4,0x0,0x0,0x4,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x4,0x0,0xe1c0,0x0,0x3e3d8,0x0,0x4,0x4,0x4,0x0,0x0,0x0,0x30218,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1c0,0x100000,0x30000,0x30000,0x4c0000,0x4c0000,0x800000,0x210,0x210,0x0,0x8,0x30218,0x0,0x0,0x0,0x210,0x210,0x210,0x210,0x0,0x0,0x30218,0x4,0x30218,0x4,0x30218,0x4,0x0,0x0,0x0,0x0,0x30218,0x4,0x1000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[33];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public VBParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public VBParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new VBParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public VBParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new VBParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public VBParser(VBParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(VBParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 171; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[154];
    for (int i = 0; i < 154; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 171; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 154; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 33; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
